<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block City Auto: Fixed Weapon Orientation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #ffeb3b;
        }

        #money {
            font-size: 32px;
            color: #4caf50;
            font-weight: bold;
            margin-top: 5px;
        }

        #wanted-level {
            display: none;
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        p {
            margin: 5px 0;
            font-size: 14px;
            opacity: 0.8;
        }

        .controls {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: inline-block;
        }

        .key {
            display: inline-block;
            padding: 2px 6px;
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }

        #message {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            display: none;
            z-index: 10;
        }

        #wasted {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(100, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ff0000;
            font-size: 80px;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 4px 4px 0 #000;
            display: none;
            z-index: 200;
        }

        #intro {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            transition: opacity 0.5s;
        }

        #intro h1 {
            font-size: 60px;
            color: #ff0055;
            text-shadow: 4px 4px 0px #000;
            margin-bottom: 10px;
        }

        #intro button {
            padding: 15px 40px;
            font-size: 20px;
            background: #ffeb3b;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 5px 0 #b3a200;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        #intro button:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #b3a200;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        #district-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 24px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            text-transform: uppercase;
            z-index: 10;
        }

        /* --- WEAPON MENU STYLES --- */
        #weapon-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffeb3b;
            border-radius: 10px;
            padding: 20px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 150;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        #weapon-menu h2 {
            color: #ffeb3b;
            margin-top: 0;
            text-transform: uppercase;
            font-size: 24px;
            border-bottom: 2px solid #555;
            width: 100%;
            text-align: center;
            padding-bottom: 10px;
        }

        .weapon-option {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #222;
            color: #888;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            text-transform: uppercase;
            cursor: pointer;
            border: 1px solid #444;
            transition: background 0.2s, color 0.2s;
        }

        .weapon-option:hover {
            background: #444;
            color: #fff;
            border-color: #666;
        }

        .weapon-option.selected {
            background: #ffeb3b;
            color: #000;
            border-color: #fff;
            box-shadow: 0 0 10px #ffeb3b;
        }

        .weapon-option.selected:hover {
            background: #ffdb1b;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="ui">
        <h1>Block City Auto</h1>
        <div id="money">$0</div>
        <div id="wanted-level">★ WANTED ★</div>
        <div class="controls">
            <p><span class="key">W</span><span class="key">S</span> Move / Menu Nav</p>
            <p><span class="key">A</span><span class="key">D</span> Turn</p>
            <p><span class="key">E</span> Weapons</p>
            <p><span class="key">SPACE</span> Jump / Select</p>
            <p><span class="key">CLICK</span> Shoot (Hold for Auto)</p>
            <p><span class="key">F</span> Enter Car</p>
        </div>
    </div>

    <div id="message">Press 'F' to Enter Vehicle</div>
    <div id="district-indicator">Downtown</div>
    <div id="crosshair"></div>
    <div id="wasted">WASTED</div>

    <div id="weapon-menu">
        <h2>Armory</h2>
        <div class="weapon-option" id="wpn-0">Hands</div>
        <div class="weapon-option selected" id="wpn-1">Handgun</div>
        <div class="weapon-option" id="wpn-2">AK-47</div>
    </div>

    <div id="intro">
        <h1>GRAND THEFT BLOCK</h1>
        <p style="font-size: 18px; margin-bottom: 30px;">Collision Reinforced. Trees Planted.</p>
        <button id="startBtn">Play Now</button>
    </div>

    <script>
        const TILE_SIZE = 20;
        const CITY_SIZE = 40;
        const GRAVITY = 30;
        const JUMP_FORCE = 12;
        const LANE_OFFSET = 5;

        let scene, camera, renderer, clock;

        // Entities
        let player;
        let cars = [];
        let policeCars = [];
        let pedestrians = [];
        const buildings = [];
        const roadTiles = new Set();
        const bullets = [];
        const particles = [];
        let garageZone = null;
        let waterPlane;

        // Weapons Config
        const WEAPONS = [
            { name: 'Hands', id: 0, type: 'none', rate: 0 },
            { name: 'Handgun', id: 1, type: 'pistol', rate: 0.3 }, // Slower firing
            { name: 'AK-47', id: 2, type: 'rifle', rate: 0.1 } // Fast Auto
        ];
        let menuSelectionIndex = 1;

        // State
        const input = { w: false, a: false, s: false, d: false, shift: false, space: false, action: false, e: false, mouseDown: false };
        let gameState = {
            inCar: false,
            activeCar: null,
            cameraTarget: null,
            money: 0,
            currentDistrict: 'Downtown',
            menuOpen: false,
            currentWeaponId: 1,
            wanted: false
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 250);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 600;
            dirLight.shadow.camera.left = -400;
            dirLight.shadow.camera.right = 400;
            dirLight.shadow.camera.top = 400;
            dirLight.shadow.camera.bottom = -400;
            scene.add(dirLight);

            generateCity();
            createPlayer();
            gameState.cameraTarget = player.mesh;

            equipWeapon(gameState.currentWeaponId);

            // Setup Mouse Click Listeners for Weapon Menu
            for (let i = 0; i < 3; i++) {
                const el = document.getElementById('wpn-' + i);
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    menuSelectionIndex = i;
                    equipWeapon(i);
                    toggleWeaponMenu();
                });
                el.addEventListener('mouseenter', () => {
                    menuSelectionIndex = i;
                    updateMenuVisuals();
                });
            }

            for (let i = 0; i < 40; i++) spawnTrafficCar();
            for (let i = 0; i < 4; i++) spawnRaceCar(); // On Track

            // Spawn parked drivable F1 cars in the city
            spawnParkedF1(20, 20);
            spawnParkedF1(80, -60);
            spawnParkedF1(-40, 100);

            for (let i = 0; i < 50; i++) spawnPedestrian();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);

            document.getElementById('startBtn').addEventListener('click', () => {
                document.getElementById('intro').style.opacity = 0;
                document.getElementById('crosshair').style.display = 'block';
                setTimeout(() => { document.getElementById('intro').style.display = 'none'; }, 500);
                clock = new THREE.Clock();
                animate();
            });
        }

        // --- Weapon Menu Logic ---
        function toggleWeaponMenu() {
            gameState.menuOpen = !gameState.menuOpen;
            const menu = document.getElementById('weapon-menu');

            if (gameState.menuOpen) {
                menu.style.display = 'flex';
                input.w = false; input.a = false; input.s = false; input.d = false; input.mouseDown = false;
                menuSelectionIndex = gameState.currentWeaponId;
                updateMenuVisuals();
            } else {
                menu.style.display = 'none';
            }
        }

        function updateMenuVisuals() {
            for (let i = 0; i < 3; i++) {
                const el = document.getElementById('wpn-' + i);
                if (i === menuSelectionIndex) el.classList.add('selected');
                else el.classList.remove('selected');
            }
        }

        function equipWeapon(id) {
            gameState.currentWeaponId = id;
            const weaponData = WEAPONS[id];

            if (player.gunMesh) {
                player.rightArm.remove(player.gunMesh);
                player.gunMesh = null;
            }

            // --- Weapon Geometry Building (Built along Z axis) ---

            if (weaponData.type === 'pistol') {
                const gunGroup = new THREE.Group();
                // Slide (Silver)
                const slide = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.25), new THREE.MeshLambertMaterial({ color: 0x888888 }));
                slide.position.set(0, 0.08, 0.05);
                gunGroup.add(slide);
                // Grip (Black)
                const grip = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.18, 0.09), new THREE.MeshLambertMaterial({ color: 0x222222 }));
                grip.position.set(0, -0.02, -0.05);
                grip.rotation.x = 0.2;
                gunGroup.add(grip);
                // Trigger Guard
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.08), new THREE.MeshLambertMaterial({ color: 0x222222 }));
                guard.position.set(0, 0.02, -0.02);
                gunGroup.add(guard);

                // Position in hand 
                gunGroup.position.set(0, -0.75, 0.1);
                gunGroup.rotation.x = -Math.PI / 2;
                player.rightArm.add(gunGroup);
                player.gunMesh = gunGroup;

            } else if (weaponData.type === 'rifle') {
                const group = new THREE.Group();
                const woodMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const metalMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const blackMat = new THREE.MeshLambertMaterial({ color: 0x111111 });

                // Scale Factor: Making it bigger (2.5x)
                const S = 2.5;

                // Receiver (Metal) - Center
                const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.08 * S, 0.1 * S, 0.25 * S), metalMat);
                group.add(receiver);

                // Handguard (Wood) - Forward
                const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.08 * S, 0.09 * S, 0.2 * S), woodMat);
                handguard.position.set(0, 0, 0.225 * S);
                group.add(handguard);

                // Stock (Wood) - Back (Flipped Y position)
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08 * S, 0.12 * S, 0.25 * S), woodMat);
                stock.position.set(0, 0.05 * S, -0.25 * S);
                stock.rotation.x = 0.2; // Flipped angle
                group.add(stock);

                // Barrel (Black) - Tip (Flipped Y position)
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02 * S, 0.02 * S, 0.3 * S, 8), blackMat);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.set(0, -0.03 * S, 0.45 * S);
                group.add(barrel);

                // Magazine (Black) - Large Banana (Flipped Y position and angle)
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.07 * S, 0.3 * S, 0.12 * S), blackMat);
                mag.position.set(0, 0.18 * S, 0.1 * S);
                mag.rotation.x = -0.4;
                group.add(mag);

                // Pistol Grip (Wood) - Bottom (Flipped Y position and angle)
                const grip = new THREE.Mesh(new THREE.BoxGeometry(0.06 * S, 0.18 * S, 0.08 * S), woodMat);
                grip.position.set(0, 0.14 * S, -0.08 * S);
                grip.rotation.x = 0.3;
                group.add(grip);

                // Position in hand
                group.position.set(0, -0.75, 0.2);
                group.rotation.x = -Math.PI / 2;

                // FIX: Rotate the group 180 degrees (Math.PI) to point Forward
                group.rotation.y = Math.PI;

                player.rightArm.add(group);
                player.gunMesh = group;
            }
        }

        // --- District & City Gen ---
        function getDistrict(x, z) {
            if (x < -100 && z < -100) return 'RaceTrack';
            if (x > 200) return 'Beach';
            if (z < -100 && x > -100) return 'Industrial';
            if (x > -100 && x < 150 && z > -100 && z < 150) return 'Downtown';
            return 'Suburbs';
        }

        function generateCity() {
            const waterGeo = new THREE.PlaneGeometry(200, 1000);
            const waterMat = new THREE.MeshLambertMaterial({ color: 0x006994, transparent: true, opacity: 0.8 });
            waterPlane = new THREE.Mesh(waterGeo, waterMat);
            waterPlane.rotation.x = -Math.PI / 2;
            waterPlane.position.set(500, -1.5, 0);
            scene.add(waterPlane);

            for (let x = -CITY_SIZE / 2; x < CITY_SIZE / 2; x++) {
                for (let z = -CITY_SIZE / 2; z < CITY_SIZE / 2; z++) {
                    const worldX = x * TILE_SIZE;
                    const worldZ = z * TILE_SIZE;
                    const district = getDistrict(worldX, worldZ);

                    if (Math.abs(worldX - 120) < 20 && Math.abs(worldZ - (-200)) < 20) {
                        createGarage(worldX, worldZ);
                        createGroundTile(worldX, worldZ, 'Industrial');
                        addRoadTile(worldX, worldZ);
                        continue;
                    }
                    if (district === 'RaceTrack') {
                        handleRaceTrackTile(worldX, worldZ);
                        continue;
                    }
                    const isRoadX = x % 4 === 0;
                    const isRoadZ = z % 4 === 0;
                    if (district === 'Beach') {
                        if (worldX > 350) {
                            createGroundTile(worldX, worldZ, 'Water');
                        } else {
                            createGroundTile(worldX, worldZ, 'Sand');
                            if (Math.random() > 0.8) createPalmTree(worldX, worldZ);
                        }
                        continue;
                    }
                    if (isRoadX || isRoadZ) {
                        addRoadTile(worldX, worldZ);
                        createGroundTile(worldX, worldZ, 'Road');
                        if (district === 'Downtown') {
                            if (isRoadX) createRoadMarking(worldX, worldZ, false);
                            if (isRoadZ && !isRoadX) createRoadMarking(worldX, worldZ, true);
                            if (isRoadX && isRoadZ) createStreetLight(worldX + 8, worldZ + 8);
                        }
                    } else {
                        createGroundTile(worldX, worldZ, district === 'Suburbs' ? 'Grass' : (district === 'Industrial' ? 'Concrete' : 'Pavement'));
                        if (Math.random() > 0.2) {
                            switch (district) {
                                case 'Downtown': createSkyscraper(worldX, worldZ); break;
                                case 'Industrial': createFactory(worldX, worldZ); break;
                                case 'Suburbs': createHouse(worldX, worldZ); break;
                            }
                        } else {
                            if (district === 'Suburbs') createPark(worldX, worldZ, true);
                            else createPark(worldX, worldZ, false);
                        }
                    }
                }
            }
        }

        function addRoadTile(x, z) {
            roadTiles.add(`${x},${z}`);
        }
        function isRoad(x, z) {
            return roadTiles.has(`${x},${z}`);
        }

        function handleRaceTrackTile(x, z) {
            let isTrack = false; let isPit = false; let isGrass = true; let isVert = false; let isHoriz = false;
            if (Math.abs(x - (-140)) < 10 && z >= -360 && z <= -160) { isTrack = true; isVert = true; }
            else if (Math.abs(z - (-360)) < 10 && x >= -300 && x <= -140) { isTrack = true; isHoriz = true; }
            else if (Math.abs(x - (-300)) < 10 && z >= -360 && z <= -280) { isTrack = true; isVert = true; }
            else if (Math.abs(z - (-280)) < 10 && x >= -300 && x <= -220) { isTrack = true; isHoriz = true; }
            else if (Math.abs(x - (-220)) < 10 && z >= -280 && z <= -200) { isTrack = true; isVert = true; }
            else if (Math.abs(z - (-200)) < 10 && x >= -300 && x <= -220) { isTrack = true; isHoriz = true; }
            else if (Math.abs(x - (-300)) < 10 && z >= -200 && z <= -160) { isTrack = true; isVert = true; }
            else if (Math.abs(z - (-160)) < 10 && x >= -300 && x <= -140) { isTrack = true; isHoriz = true; }
            else if (Math.abs(x - (-180)) < 10 && z >= -320 && z <= -200) isPit = true;

            if (Math.abs(x - (-100)) < 10 && z >= -340 && z <= -180) { createGrandstand(x, z, -Math.PI / 2); isGrass = false; }
            else if (Math.abs(z - (-400)) < 10 && x >= -280 && x <= -160) { createGrandstand(x, z, 0); isGrass = false; }

            if (isTrack) {
                createGroundTile(x, z, 'Track');
                const OFFSET = 9;
                const isTopRight = (Math.abs(x - (-140)) < 5 && Math.abs(z - (-360)) < 5);
                const isTopLeft = (Math.abs(x - (-300)) < 5 && Math.abs(z - (-360)) < 5);
                const isBottomLeft = (Math.abs(x - (-300)) < 5 && Math.abs(z - (-160)) < 5);
                const isBottomRight = (Math.abs(x - (-140)) < 5 && Math.abs(z - (-160)) < 5);
                const isChicane1 = (Math.abs(x - (-300)) < 5 && Math.abs(z - (-280)) < 5);
                const isChicane2 = (Math.abs(x - (-220)) < 5 && Math.abs(z - (-280)) < 5);
                const isChicane3 = (Math.abs(x - (-220)) < 5 && Math.abs(z - (-200)) < 5);
                const isChicane4 = (Math.abs(x - (-300)) < 5 && Math.abs(z - (-200)) < 5);

                if (isTopRight) { createCurb(x, z, true, -OFFSET); createCurb(x, z, false, OFFSET); }
                else if (isTopLeft) { createCurb(x, z, true, -OFFSET); createCurb(x, z, false, -OFFSET); }
                else if (isBottomLeft) { createCurb(x, z, true, OFFSET); createCurb(x, z, false, -OFFSET); }
                else if (isBottomRight) { createCurb(x, z, true, OFFSET); createCurb(x, z, false, OFFSET); }
                else if (isChicane1) { createCurb(x, z, true, OFFSET); createCurb(x, z, false, -OFFSET); }
                else if (isChicane2) { createCurb(x, z, true, -OFFSET); createCurb(x, z, false, OFFSET); }
                else if (isChicane3) { createCurb(x, z, true, OFFSET); createCurb(x, z, false, OFFSET); }
                else if (isChicane4) { createCurb(x, z, true, -OFFSET); createCurb(x, z, false, -OFFSET); }
                else {
                    if (isVert) { createCurb(x, z, false, -OFFSET); createCurb(x, z, false, OFFSET); }
                    else if (isHoriz) { createCurb(x, z, true, -OFFSET); createCurb(x, z, true, OFFSET); }
                }
            } else if (isPit) {
                createGroundTile(x, z, 'Pit');
                if (z % 40 === 0) createPitGarage(x - 12, z);
            } else if (isGrass) {
                createGroundTile(x, z, 'RaceGrass');
                if (Math.random() > 0.97) createStreetLight(x, z);
            }
        }

        function createGroundTile(x, z, type) {
            const geo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
            let color = 0x333333;
            if (type === 'Sand') color = 0xF4A460;
            else if (type === 'Grass' || type === 'RaceGrass') color = type === 'RaceGrass' ? 0x66bb6a : 0x4CAF50;
            else if (type === 'Concrete') color = 0x555555;
            else if (type === 'Pavement') color = 0x777777;
            else if (type === 'Track') color = 0x222222;
            else if (type === 'Pit') color = 0x444444;
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(x, -0.1, z);
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createCurb(x, z, isHorizontal, offset) {
            let sx = isHorizontal ? TILE_SIZE : 1.5;
            let sz = isHorizontal ? 1.5 : TILE_SIZE;
            const geo = new THREE.BoxGeometry(sx, 0.2, sz);
            const tex = new THREE.CanvasTexture(createStripesCanvas(isHorizontal));
            tex.magFilter = THREE.NearestFilter;
            const mat = new THREE.MeshLambertMaterial({ map: tex });
            const mesh = new THREE.Mesh(geo, mat);
            if (isHorizontal) mesh.position.set(x, 0.05, z + offset);
            else mesh.position.set(x + offset, 0.05, z);
            scene.add(mesh);
        }

        function createStripesCanvas(isHorizontal) {
            const c = document.createElement('canvas'); c.width = 64; c.height = 64;
            const ctx = c.getContext('2d');
            if (isHorizontal) {
                ctx.fillStyle = '#cc0000'; ctx.fillRect(0, 0, 32, 64);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(32, 0, 32, 64);
            } else {
                ctx.fillStyle = '#cc0000'; ctx.fillRect(0, 0, 64, 32);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 32, 64, 32);
            }
            return c;
        }

        // --- Buildings ---
        function createGrandstand(x, z, rotation) {
            const group = new THREE.Group();
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const stairGeo = new THREE.BoxGeometry(TILE_SIZE, 1.5, 4);
            for (let i = 0; i < 6; i++) {
                const step = new THREE.Mesh(stairGeo, baseMat);
                step.position.set(0, i * 1.5, i * 3 - 8); group.add(step);
                const seatColor = (Math.floor(x / TILE_SIZE) + i) % 2 === 0 ? 0xcc0000 : 0x0000cc;
                const seat = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE - 1, 0.4, 3), new THREE.MeshLambertMaterial({ color: seatColor }));
                seat.position.set(0, i * 1.5 + 0.8, i * 3 - 8); group.add(seat);
            }
            const wall = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 12, 2), baseMat);
            wall.position.set(0, 6, 8); group.add(wall);
            const roof = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 1, 20), new THREE.MeshLambertMaterial({ color: 0xeeeeee }));
            roof.position.set(0, 14, 0); roof.rotation.x = 0.1; group.add(roof);
            const pillarGeo = new THREE.CylinderGeometry(0.5, 0.5, 14);
            const p1 = new THREE.Mesh(pillarGeo, baseMat); p1.position.set(9, 7, 8); group.add(p1);
            const p2 = new THREE.Mesh(pillarGeo, baseMat); p2.position.set(-9, 7, 8); group.add(p2);
            group.position.set(x, 0, z); group.rotation.y = rotation;
            scene.add(group);
            group.updateMatrixWorld();
            buildings.push(new THREE.Box3().setFromObject(group));
        }

        function createPitGarage(x, z) {
            const group = new THREE.Group();
            const box = new THREE.Mesh(new THREE.BoxGeometry(10, 6, 18), new THREE.MeshLambertMaterial({ color: 0xcccccc }));
            box.position.y = 3; group.add(box);
            const door = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 12), new THREE.MeshLambertMaterial({ color: 0x222222 }));
            door.position.set(4.6, 2.5, 0); group.add(door);
            group.position.set(x, 0, z); scene.add(group);
            group.updateMatrixWorld();
            buildings.push(new THREE.Box3().setFromObject(group));
        }

        function createSkyscraper(x, z) {
            const h = Math.random() * 80 + 50;
            const w = TILE_SIZE - 2;
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(0.6, 0.2, Math.random() * 0.5 + 0.2) }));
            m.position.set(x, h / 2, z); m.castShadow = true; m.receiveShadow = true; scene.add(m);
            m.updateMatrixWorld();
            buildings.push(new THREE.Box3().setFromObject(m));
        }

        function createFactory(x, z) {
            const h = Math.random() * 20 + 15; const w = TILE_SIZE - 2;
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
            b.position.y = h / 2; b.castShadow = true; g.add(b);
            if (Math.random() > 0.5) {
                const s = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, h + 10), new THREE.MeshLambertMaterial({ color: 0x333333 }));
                s.position.set(4, h / 2 + 5, 4); g.add(s);
            }
            g.position.set(x, 0, z); scene.add(g);
            g.updateMatrixWorld();
            buildings.push(new THREE.Box3().setFromObject(b));
        }

        function createHouse(x, z) {
            const h = 6; const w = TILE_SIZE - 8; const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshLambertMaterial({ color: 0xEFEFEF }));
            b.position.y = h / 2; b.castShadow = true; g.add(b);
            const r = new THREE.Mesh(new THREE.ConeGeometry(w * 0.8, 4, 4), new THREE.MeshLambertMaterial({ color: 0xA52A2A }));
            r.position.y = h + 2; r.rotation.y = Math.PI / 4; g.add(r);
            g.position.set(x, 0, z); scene.add(g);
            g.updateMatrixWorld();
            buildings.push(new THREE.Box3().setFromObject(b));
        }

        function createGarage(x, z) {
            const g = new THREE.Group(); const wm = new THREE.MeshLambertMaterial({ color: 0x553333 });
            const bw = new THREE.Mesh(new THREE.BoxGeometry(30, 12, 2), wm); bw.position.set(0, 6, -14); g.add(bw);
            const lw = new THREE.Mesh(new THREE.BoxGeometry(2, 12, 30), wm); lw.position.set(-14, 6, 0); g.add(lw);
            const rw = new THREE.Mesh(new THREE.BoxGeometry(2, 12, 30), wm); rw.position.set(14, 6, 0); g.add(rw);
            const r = new THREE.Mesh(new THREE.BoxGeometry(32, 1, 32), new THREE.MeshLambertMaterial({ color: 0x222222 })); r.position.set(0, 12, 0); g.add(r);
            const s = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 1), new THREE.MeshBasicMaterial({ color: 0xFF00FF })); s.position.set(0, 14, -14); g.add(s);
            g.position.set(x, 0, z); scene.add(g);
            garageZone = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x, 2, z), new THREE.Vector3(26, 6, 26));

            g.updateMatrixWorld();
            buildings.push(new THREE.Box3().setFromObject(bw));
            buildings.push(new THREE.Box3().setFromObject(lw));
            buildings.push(new THREE.Box3().setFromObject(rw));
        }

        // --- Nature ---
        function createPalmTree(x, z) {
            const g = new THREE.Group(); const t = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 8), new THREE.MeshLambertMaterial({ color: 0x8B4513 })); t.position.y = 4; g.add(t);
            const l = new THREE.Mesh(new THREE.ConeGeometry(3, 2, 5), new THREE.MeshLambertMaterial({ color: 0x228B22 })); l.position.y = 8; g.add(l); g.position.set(x + (Math.random() - 0.5) * 10, 0, z + (Math.random() - 0.5) * 10); scene.add(g);
        }

        function createOakTree(x, z) {
            const g = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 4), new THREE.MeshLambertMaterial({ color: 0x8B4513 })); t.position.y = 2; g.add(t);
            const l = new THREE.Mesh(new THREE.DodecahedronGeometry(3), new THREE.MeshLambertMaterial({ color: 0x228B22 })); l.position.y = 4.5; g.add(l);
            g.position.set(x + (Math.random() - 0.5) * 10, 0, z + (Math.random() - 0.5) * 10); scene.add(g);
        }

        function createPineTree(x, z) {
            const g = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 3), new THREE.MeshLambertMaterial({ color: 0x3E2723 })); t.position.y = 1.5; g.add(t);
            const l = new THREE.Mesh(new THREE.ConeGeometry(2.5, 7, 8), new THREE.MeshLambertMaterial({ color: 0x1B5E20 })); l.position.y = 5; g.add(l);
            g.position.set(x + (Math.random() - 0.5) * 10, 0, z + (Math.random() - 0.5) * 10); scene.add(g);
        }

        function createPark(x, z, hasTree) {
            if (hasTree) {
                const r = Math.random();
                if (r < 0.33) createPalmTree(x, z);
                else if (r < 0.66) createOakTree(x, z);
                else createPineTree(x, z);
            }
        }

        function createRoadMarking(x, z, r) {
            const m = new THREE.Mesh(new THREE.PlaneGeometry(1, 6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            m.rotation.x = -Math.PI / 2; if (r) m.rotation.z = Math.PI / 2; m.position.set(x, 0.01, z); scene.add(m);
        }
        function createStreetLight(x, z) {
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 8), new THREE.MeshLambertMaterial({ color: 0x555555 })); p.position.set(x, 4, z); scene.add(p);
            const l = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 0.8), new THREE.MeshLambertMaterial({ color: 0x444444 })); l.position.set(0, 4, -1); p.add(l);
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 0.5), new THREE.MeshBasicMaterial({ color: 0xffffaa })); b.position.y = -0.2; l.add(b);
        }

        function createPlayer() {
            const group = new THREE.Group();

            // Dimensions (Taller Character)
            const legH = 1.2; // Increased
            const bodyH = 1.0; // Increased
            const headH = 0.6;
            const bodyWidth = 0.9;
            const bodyDepth = 0.5;

            // Body (Torso)
            // Sit perfectly on top of legs. Y center = legHeight + bodyHeight/2
            const body = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, bodyH, bodyDepth), new THREE.MeshLambertMaterial({ color: 0x2196F3 }));
            body.position.y = legH + (bodyH / 2);
            body.castShadow = true;
            group.add(body);

            // Head
            // Sits on top of body. Y center = legH + bodyH + headH/2
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, headH, 0.6), new THREE.MeshLambertMaterial({ color: 0xffccaa }));
            head.position.y = legH + bodyH + (headH / 2);
            group.add(head);

            // Shoulder Height for Arms (Near top of body)
            const shoulderY = legH + bodyH - 0.15;

            // Right Arm
            const rightArmPivot = new THREE.Group();
            rightArmPivot.position.set(bodyWidth / 2 + 0.15, shoulderY, 0);
            group.add(rightArmPivot);
            const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.75, 0.3), new THREE.MeshLambertMaterial({ color: 0x2196F3 }));
            rightArm.position.y = -0.375; // Offset geometry so pivot is at top
            rightArmPivot.add(rightArm);

            // Left Arm
            const leftArmPivot = new THREE.Group();
            leftArmPivot.position.set(-(bodyWidth / 2 + 0.15), shoulderY, 0);
            group.add(leftArmPivot);
            const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.75, 0.3), new THREE.MeshLambertMaterial({ color: 0x2196F3 }));
            leftArm.position.y = -0.375;
            leftArmPivot.add(leftArm);

            // Legs
            // Pivot point is the hip (top of leg) at height legH
            const legGeo = new THREE.BoxGeometry(0.35, legH, 0.35);
            legGeo.translate(0, -legH / 2, 0); // Translate so pivot is at top
            const legMat = new THREE.MeshLambertMaterial({ color: 0x1565C0 });

            // Left Leg
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.25, legH, 0); // At Hip height
            group.add(leftLeg);

            // Right Leg
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.25, legH, 0); // At Hip height
            group.add(rightLeg);

            // Spawn Position
            const roads = Array.from(roadTiles);
            if (roads.length > 0) {
                const downtownRoads = roads.filter(r => {
                    const [x, z] = r.split(',').map(Number);
                    return Math.abs(x) < 50 && Math.abs(z) < 50;
                });
                const key = downtownRoads.length > 0 ? downtownRoads[0] : roads[0];
                const [sx, sz] = key.split(',').map(Number);
                group.position.set(sx, 0, sz);
            } else {
                group.position.set(0, 0, 0);
            }

            scene.add(group);
            player = {
                mesh: group,
                rightArm: rightArmPivot,
                leftArm: leftArmPivot,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                gunMesh: null,
                velocity: new THREE.Vector3(),
                speed: 10,
                runSpeed: 20,
                rotationSpeed: 3.5,
                dy: 0,
                isGrounded: true,
                shootTimer: 0,
                walkTimer: 0
            };
        }

        function spawnTrafficCar() {
            const roads = Array.from(roadTiles);
            if (roads.length === 0) return;
            const key = roads[Math.floor(Math.random() * roads.length)];
            const [sx, sz] = key.split(',').map(Number);
            const isNS = isRoad(sx, sz + TILE_SIZE) || isRoad(sx, sz - TILE_SIZE);
            const isEW = isRoad(sx + TILE_SIZE, sz) || isRoad(sx - TILE_SIZE, sz);
            let dir = new THREE.Vector3(); let pos = new THREE.Vector3(sx, 0, sz); let rot = 0;
            if (isNS && (!isEW || Math.random() > 0.5)) {
                if (Math.random() > 0.5) { dir.set(0, 0, 1); pos.x -= LANE_OFFSET; rot = 0; }
                else { dir.set(0, 0, -1); pos.x += LANE_OFFSET; rot = Math.PI; }
            } else {
                if (Math.random() > 0.5) { dir.set(1, 0, 0); pos.z += LANE_OFFSET; rot = -Math.PI / 2; }
                else { dir.set(-1, 0, 0); pos.z -= LANE_OFFSET; rot = Math.PI / 2; }
            }
            const type = Math.random() > 0.6 ? (Math.random() > 0.8 ? 'sport' : 'pickup') : 'sedan';
            const car = createCarMesh(type);
            car.position.copy(pos); car.rotation.y = rot; scene.add(car);
            let maxSpeed = type === 'sport' ? 60 : (type === 'pickup' ? 25 : 30);
            cars.push({ mesh: car, speed: 0, maxSpeed: maxSpeed + Math.random() * 10, acceleration: 10, health: 100, isPlayer: false, changeDirTimer: 0, type: 'traffic', targetSpeed: maxSpeed });
        }

        function spawnRaceCar() {
            const x = -140; const z = -200 + (Math.random() * 40);
            const car = createCarMesh('racer');
            car.position.set(x, 0, z); car.rotation.y = Math.PI; scene.add(car);
            cars.push({ mesh: car, speed: 0, maxSpeed: 80, acceleration: 25, health: 150, isPlayer: false, changeDirTimer: 0, type: 'racer', targetSpeed: 80 });
        }

        // New function to spawn parked F1 cars in the city
        function spawnParkedF1(x, z) {
            const car = createCarMesh('racer');
            // Place on ground at specified coords, random rotation
            car.position.set(x, 0, z);
            car.rotation.y = Math.random() * Math.PI * 2;
            scene.add(car);
            // Add to cars array so it's drivable. Max speed 90 (fastest in game)
            cars.push({ mesh: car, speed: 0, maxSpeed: 90, acceleration: 28, health: 150, isPlayer: false, changeDirTimer: 0, type: 'racer', targetSpeed: 0 });
        }

        function spawnPolice() {
            if (policeCars.length > 0) return; // Limit to 1 for simplicity
            const roads = Array.from(roadTiles);
            // Find a road tile about 40 units away from player
            const pPos = gameState.activeCar ? gameState.activeCar.mesh.position : player.mesh.position;
            let bestKey = roads[0]; let bestDist = 9999;
            for (let r of roads) {
                const [sx, sz] = r.split(',').map(Number);
                const d = Math.abs(sx - pPos.x) + Math.abs(sz - pPos.z);
                if (d > 30 && d < 80) { bestKey = r; break; }
            }
            const [sx, sz] = bestKey.split(',').map(Number);

            const car = createCarMesh('police');
            car.position.set(sx, 0, sz);
            scene.add(car);
            policeCars.push({
                mesh: car,
                speed: 0,
                maxSpeed: 32, // Faster than sedan
                acceleration: 15,
                health: 200,
                sirenTimer: 0,
                sirens: car.userData.sirens
            });
        }

        function createCarMesh(type) {
            const group = new THREE.Group();
            let color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
            if (type === 'racer') color = new THREE.Color(0xff0000);
            if (type === 'sport') color = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
            if (type === 'police') color = new THREE.Color(0x111111); // Black body

            const chassisGeo = new THREE.BoxGeometry(2.2, 1, 4.5);
            if (type === 'pickup') chassisGeo.scale(1, 1.2, 1);
            if (type === 'sport') chassisGeo.scale(1, 0.7, 1);
            const chassis = new THREE.Mesh(chassisGeo, new THREE.MeshLambertMaterial({ color: color }));
            chassis.position.y = 0.8; chassis.castShadow = true; group.add(chassis);

            if (type === 'police') {
                // White Doors
                const door = new THREE.Mesh(new THREE.BoxGeometry(2.25, 0.8, 2.0), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                door.position.y = 0.8; group.add(door);
            }

            let cabinGeo = new THREE.BoxGeometry(1.8, 0.8, 2.5);
            let cabinPos = new THREE.Vector3(0, 1.7, -0.2);
            if (type === 'pickup') {
                cabinGeo = new THREE.BoxGeometry(1.8, 0.9, 1.5);
                cabinPos = new THREE.Vector3(0, 1.8, 0.5);
                const bedL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 2), new THREE.MeshLambertMaterial({ color: color }));
                bedL.position.set(1, 1.6, -1.2); group.add(bedL);
                const bedR = bedL.clone(); bedR.position.set(-1, 1.6, -1.2); group.add(bedR);
            } else if (type === 'sport') {
                cabinGeo = new THREE.BoxGeometry(1.6, 0.6, 2.0);
                cabinPos = new THREE.Vector3(0, 1.4, -0.2);
            }
            const cabin = new THREE.Mesh(cabinGeo, new THREE.MeshLambertMaterial({ color: 0x333333 }));
            cabin.position.copy(cabinPos); group.add(cabin);

            // Spoilers
            if (type === 'racer' || type === 'sport') {
                const spoiler = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 0.5), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                spoiler.position.set(0, 1.6, -2.2); group.add(spoiler);
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), new THREE.MeshLambertMaterial({ color: 0x111111 }));
                post.position.set(0.8, 1.4, -2.2); group.add(post);
                const post2 = post.clone(); post2.position.set(-0.8, 1.4, -2.2); group.add(post2);
            }

            // Siren for Police
            if (type === 'police') {
                const bar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.15, 0.4), new THREE.MeshLambertMaterial({ color: 0x222222 }));
                bar.position.set(0, 2.15, -0.2); group.add(bar);
                const sL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                sL.position.set(-0.5, 2.15, -0.2); group.add(sL);
                const sR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), new THREE.MeshBasicMaterial({ color: 0x0000ff }));
                sR.position.set(0.5, 2.15, -0.2); group.add(sR);
                group.userData.sirens = { left: sL, right: sR };
            }

            const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const l1 = new THREE.Mesh(lightGeo, lightMat); l1.position.set(0.7, 0.8, 2.26); group.add(l1);
            const l2 = new THREE.Mesh(lightGeo, lightMat); l2.position.set(-0.7, 0.8, 2.26); group.add(l2);

            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
            const wheelMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const wheelRot = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);
            [{ x: -1.1, z: 1.5 }, { x: 1.1, z: 1.5 }, { x: -1.1, z: -1.5 }, { x: 1.1, z: -1.5 }].forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.quaternion.copy(wheelRot); w.position.set(pos.x, 0.4, pos.z); group.add(w);
            });
            return group;
        }

        function onKeyDown(event) {
            const k = event.key.toLowerCase();
            if (k === 'e' && !gameState.inCar) { toggleWeaponMenu(); return; }
            if (gameState.menuOpen) {
                if (k === 'w') { menuSelectionIndex--; if (menuSelectionIndex < 0) menuSelectionIndex = 2; updateMenuVisuals(); }
                if (k === 's') { menuSelectionIndex++; if (menuSelectionIndex > 2) menuSelectionIndex = 0; updateMenuVisuals(); }
                if (k === ' ' || k === 'enter' || k === 'f') { equipWeapon(menuSelectionIndex); toggleWeaponMenu(); }
                return;
            }
            switch (k) {
                case 'w': input.w = true; break;
                case 'a': input.a = true; break;
                case 's': input.s = true; break;
                case 'd': input.d = true; break;
                case ' ': input.space = true; break;
                case 'shift': input.shift = true; break;
                case 'f': case 'enter': if (!input.action) handleInteraction(); input.action = true; break;
            }
        }
        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w': input.w = false; break;
                case 'a': input.a = false; break;
                case 's': input.s = false; break;
                case 'd': input.d = false; break;
                case ' ': input.space = false; break;
                case 'shift': input.shift = false; break;
                case 'f': case 'enter': input.action = false; break;
            }
        }

        function onMouseDown() {
            if (gameState.menuOpen) return;
            if (!gameState.inCar) input.mouseDown = true;
        }

        function onMouseUp() {
            input.mouseDown = false;
        }

        function handleInteraction() {
            if (gameState.inCar) exitCar();
            else enterCar();
        }
        function enterCar() {
            let nearest = 8, target = null;
            cars.forEach(c => { const d = player.mesh.position.distanceTo(c.mesh.position); if (d < nearest) { nearest = d; target = c; } });
            if (target) {
                gameState.inCar = true; gameState.activeCar = target; target.isPlayer = true;
                player.mesh.visible = false; gameState.cameraTarget = target.mesh;
                document.getElementById('crosshair').style.display = 'none';
                if (gameState.menuOpen) toggleWeaponMenu();

                // Trigger Police if not your own car (conceptually all cars are stealable)
                if (target.type === 'traffic' || target.type === 'racer') {
                    if (!gameState.wanted) {
                        gameState.wanted = true;
                        document.getElementById('wanted-level').style.display = 'block';
                        spawnPolice();
                    }
                }
            }
        }
        function exitCar() {
            if (!gameState.activeCar) return;
            const offset = new THREE.Vector3(-3, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.activeCar.mesh.rotation.y);
            player.mesh.position.copy(gameState.activeCar.mesh.position).add(offset); player.mesh.position.y = 0;
            gameState.inCar = false; gameState.activeCar.isPlayer = false; gameState.activeCar = null;
            player.mesh.visible = true; gameState.cameraTarget = player.mesh;
            document.getElementById('crosshair').style.display = 'block';
        }
        function shootGun() {
            const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            const isRifle = WEAPONS[gameState.currentWeaponId].type === 'rifle';
            const zOffset = isRifle ? 2.5 : 1.5;
            const offset = new THREE.Vector3(0.5, 2, zOffset).applyQuaternion(player.mesh.quaternion);
            bullet.position.copy(player.mesh.position).add(offset);
            const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(player.mesh.quaternion);
            scene.add(bullet); bullets.push({ mesh: bullet, dir: dir, life: 2.0 });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            const pos = gameState.activeCar ? gameState.activeCar.mesh.position : player.mesh.position;
            const dist = getDistrict(pos.x, pos.z);
            if (dist !== gameState.currentDistrict) {
                gameState.currentDistrict = dist;
                document.getElementById('district-indicator').innerText = dist;
            }

            if (gameState.inCar) { updateCarPhysics(gameState.activeCar, dt, true); checkGarage(); }
            else if (!gameState.menuOpen) updatePlayerPhysics(dt);

            cars.forEach(c => { if (!c.isPlayer) updateCarPhysics(c, dt, false); });
            updatePolice(dt);
            updatePedestrians(dt);
            updateBullets(dt);
            updateParticles(dt);
            updateCamera();
            checkInteractionPrompt();

            renderer.render(scene, camera);
        }

        function updatePolice(dt) {
            for (let i = policeCars.length - 1; i >= 0; i--) {
                const p = policeCars[i];

                // Siren Lights Logic
                p.sirenTimer += dt * 10;
                if (Math.floor(p.sirenTimer) % 2 === 0) {
                    p.sirens.left.material.color.setHex(0xff0000);
                    p.sirens.right.material.color.setHex(0x222222);
                } else {
                    p.sirens.left.material.color.setHex(0x222222);
                    p.sirens.right.material.color.setHex(0x0000ff);
                }

                // Chase Logic
                const targetPos = gameState.activeCar ? gameState.activeCar.mesh.position : player.mesh.position;

                // Simple Steering: Turn towards player
                const pPos = p.mesh.position.clone();
                const dir = targetPos.clone().sub(pPos).normalize();

                // Calculate angle to target
                const angle = Math.atan2(dir.x, dir.z);
                // Smooth turn
                let angleDiff = angle - p.mesh.rotation.y;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                p.mesh.rotation.y += Math.min(Math.max(angleDiff, -2 * dt), 2 * dt);

                // Drive forward
                const fwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), p.mesh.rotation.y);
                const next = p.mesh.position.clone().add(fwd.multiplyScalar(p.maxSpeed * dt));

                if (!checkCollision(next)) {
                    p.mesh.position.copy(next);
                } else {
                    // Slide if hit building
                    p.mesh.rotation.y += Math.PI / 4;
                }

                // Hit Player Logic
                if (gameState.activeCar) {
                    const dist = p.mesh.position.distanceTo(gameState.activeCar.mesh.position);
                    if (dist < 3.5) {
                        // Ramming
                        gameState.activeCar.health -= 0.5;
                        p.mesh.position.sub(fwd.multiplyScalar(0.5)); // Bounce back slightly
                        spawnExplosionParticle(gameState.activeCar.mesh.position);
                    }
                }
            }
        }

        function updatePlayerPhysics(dt) {
            if (!player.mesh.visible) return;

            // Shooting Logic
            const wpn = WEAPONS[gameState.currentWeaponId];
            if (player.shootTimer > 0) player.shootTimer -= dt;
            if (input.mouseDown && wpn.type !== 'none' && player.shootTimer <= 0) {
                shootGun();
                player.shootTimer = wpn.rate;
            }

            // Recoil
            if (player.shootTimer > 0 && wpn.type !== 'none') {
                player.rightArm.rotation.x = THREE.MathUtils.lerp(player.rightArm.rotation.x, -Math.PI / 2 - 0.2, 10 * dt);
            } else {
                player.rightArm.rotation.x = THREE.MathUtils.lerp(player.rightArm.rotation.x, 0, 5 * dt);
            }

            // Rotation
            if (input.a) player.mesh.rotation.y += player.rotationSpeed * dt;
            if (input.d) player.mesh.rotation.y -= player.rotationSpeed * dt;

            // Movement & Animation
            const speed = input.shift ? player.runSpeed : player.speed;
            const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(player.mesh.quaternion);
            const move = new THREE.Vector3(0, 0, 0);
            if (input.w) move.add(fwd); if (input.s) move.sub(fwd);

            const isMoving = (input.w || input.s);
            if (isMoving) {
                // Leg Animation
                player.walkTimer += dt * (input.shift ? 15 : 10);
                player.leftLeg.rotation.x = Math.sin(player.walkTimer) * 0.8;
                player.rightLeg.rotation.x = Math.sin(player.walkTimer + Math.PI) * 0.8;
                // Arm Swing (Left Arm)
                player.leftArm.rotation.x = Math.sin(player.walkTimer + Math.PI) * 0.5;
            } else {
                // Reset Limbs
                player.leftLeg.rotation.x = THREE.MathUtils.lerp(player.leftLeg.rotation.x, 0, 10 * dt);
                player.rightLeg.rotation.x = THREE.MathUtils.lerp(player.rightLeg.rotation.x, 0, 10 * dt);
                player.leftArm.rotation.x = THREE.MathUtils.lerp(player.leftArm.rotation.x, 0, 10 * dt);
            }

            player.velocity.x = move.x * speed; player.velocity.z = move.z * speed;
            if (player.isGrounded && input.space) { player.dy = JUMP_FORCE; player.isGrounded = false; }
            player.dy -= GRAVITY * dt; player.velocity.y = player.dy;
            const next = player.mesh.position.clone().add(player.velocity.clone().multiplyScalar(dt));
            if (next.y <= 0) { next.y = 0; player.dy = 0; player.isGrounded = true; }
            if (!checkCollision(next)) player.mesh.position.copy(next);
            else player.mesh.position.y = next.y;
        }

        function updateCarPhysics(car, dt, isPlayer) {
            if (car.health <= 0) return;
            if (isPlayer) {
                if (input.w) car.speed += car.acceleration * dt;
                else if (input.s) car.speed -= car.acceleration * dt;
                else car.speed *= 0.98;
                if (Math.abs(car.speed) > 0.5) {
                    const rot = 2.5 * dt * (car.speed > 0 ? 1 : -1);
                    if (input.a) car.mesh.rotation.y += rot; if (input.d) car.mesh.rotation.y -= rot;
                }
            } else if (car.type === 'traffic') {
                car.speed = car.targetSpeed * 0.5;
                const fwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                car.mesh.position.add(fwd.multiplyScalar(car.speed * dt));
                const tx = Math.round(car.mesh.position.x / TILE_SIZE) * TILE_SIZE;
                const tz = Math.round(car.mesh.position.z / TILE_SIZE) * TILE_SIZE;
                const distToCenter = Math.abs(car.mesh.position.x - tx) + Math.abs(car.mesh.position.z - tz);
                if (distToCenter < 2) {
                    const ry = car.mesh.rotation.y;
                    const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y).round();
                    const nN = isRoad(tx, tz - TILE_SIZE); const nS = isRoad(tx, tz + TILE_SIZE);
                    const nE = isRoad(tx + TILE_SIZE, tz); const nW = isRoad(tx - TILE_SIZE, tz);
                    let possible = [];
                    if (dir.z > 0.5 && nS) possible.push('S'); if (dir.z < -0.5 && nN) possible.push('N');
                    if (dir.x > 0.5 && nE) possible.push('E'); if (dir.x < -0.5 && nW) possible.push('W');
                    if (nS && dir.z > -0.5) possible.push('S'); if (nN && dir.z < 0.5) possible.push('N');
                    if (nE && dir.x > -0.5) possible.push('E'); if (nW && dir.x < 0.5) possible.push('W');
                    possible = [...new Set(possible)];
                    if (possible.length > 0) {
                        let chosen = possible[Math.floor(Math.random() * possible.length)];
                        if (chosen === 'N') { car.mesh.rotation.y = Math.PI; car.mesh.position.x = tx + LANE_OFFSET; }
                        if (chosen === 'S') { car.mesh.rotation.y = 0; car.mesh.position.x = tx - LANE_OFFSET; }
                        if (chosen === 'E') { car.mesh.rotation.y = -Math.PI / 2; car.mesh.position.z = tz + LANE_OFFSET; }
                        if (chosen === 'W') { car.mesh.rotation.y = Math.PI / 2; car.mesh.position.z = tz - LANE_OFFSET; }
                        const newFwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                        car.mesh.position.add(newFwd.multiplyScalar(4));
                    } else {
                        car.mesh.rotation.y += Math.PI;
                        const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                        car.mesh.position.add(right.multiplyScalar(LANE_OFFSET * 2));
                    }
                }
            } else {
                car.speed = 15; car.changeDirTimer -= dt; if (car.changeDirTimer <= 0) car.changeDirTimer = 2.0;
                const fwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                const next = car.mesh.position.clone().add(fwd.multiplyScalar(car.speed * dt));
                if (!checkCollision(next)) car.mesh.position.copy(next);
                else { car.speed = -car.speed; car.mesh.rotation.y += Math.PI / 2; }
            }

            if (isPlayer) {
                car.speed = Math.max(Math.min(car.speed, car.maxSpeed), -car.maxSpeed / 2);
                const fwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), car.mesh.rotation.y);
                const nextPos = car.mesh.position.clone().add(fwd.multiplyScalar(car.speed * dt));
                if (!checkCollision(nextPos)) { car.mesh.position.copy(nextPos); }
                else { car.health -= Math.abs(car.speed) * 2; car.speed = -car.speed * 0.5; }
            }
            const lim = (CITY_SIZE * TILE_SIZE) / 2 + 20;
            if (car.mesh.position.x > lim) car.mesh.position.x = -lim; if (car.mesh.position.x < -lim) car.mesh.position.x = lim;
            if (car.mesh.position.z > lim) car.mesh.position.z = -lim; if (car.mesh.position.z < -lim) car.mesh.position.z = lim;
            if (car.health < 50) { car.smokeTimer -= dt; if (car.smokeTimer <= 0) { spawnSmoke(car.mesh.position); car.smokeTimer = 0.1; } }
            if (car.health <= 0) explodeCar(car);
        }

        function checkGarage() {
            if (!gameState.activeCar || !garageZone) return;
            const box = new THREE.Box3().setFromObject(gameState.activeCar.mesh);
            if (garageZone.intersectsBox(box)) {
                gameState.money += 500; document.getElementById('money').innerText = "$" + gameState.money;
                const msg = document.getElementById('message');
                msg.innerText = "CAR SOLD: +$500 (Police evaded)"; msg.style.display = 'block'; msg.style.color = '#4caf50';

                // Reset Wanted Level
                gameState.wanted = false;
                document.getElementById('wanted-level').style.display = 'none';
                policeCars.forEach(p => scene.remove(p.mesh));
                policeCars = [];

                setTimeout(() => { msg.style.display = 'none'; msg.style.color = 'white'; }, 2000);
                const old = gameState.activeCar; exitCar(); scene.remove(old.mesh); cars = cars.filter(c => c !== old);
                player.mesh.position.z += 15;
            }
        }

        function explodeCar(car) {
            for (let i = 0; i < 20; i++) spawnExplosionParticle(car.mesh.position);
            if (car.isPlayer) {
                document.getElementById('wasted').style.display = 'flex'; player.mesh.visible = false;
                setTimeout(() => document.location.reload(), 3000);
            }
            scene.remove(car.mesh); cars = cars.filter(c => c !== car);
            if (gameState.activeCar === car) gameState.activeCar = null;
        }

        function spawnSmoke(pos) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true }));
            p.position.copy(pos).add(new THREE.Vector3((Math.random() - 0.5) * 2, 1, (Math.random() - 0.5) * 2));
            scene.add(p); particles.push({ mesh: p, life: 1.0, vy: 5 + Math.random() * 5, type: 'smoke' });
        }
        function spawnExplosionParticle(pos) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff0000 : 0xffaa00 }));
            p.position.copy(pos);
            scene.add(p); particles.push({ mesh: p, life: 0.8, vel: new THREE.Vector3(Math.random() - 0.5, Math.random(), Math.random() - 0.5).normalize().multiplyScalar(10 + Math.random() * 10), type: 'fire' });
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.life -= dt;
                if (p.type === 'smoke') { p.mesh.position.y += p.vy * dt; p.mesh.scale.multiplyScalar(1.02); p.mesh.material.opacity = p.life; }
                else p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
        }

        function spawnPedestrian() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.4, 0.4), new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.6, 0.5) }));
            b.position.y = 1.4; g.add(b);
            const h = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshLambertMaterial({ color: 0xffccaa }));
            h.position.y = 2.4; g.add(h);
            let x, z;
            do {
                x = (Math.random() * CITY_SIZE - CITY_SIZE / 2) * TILE_SIZE;
                z = (Math.random() * CITY_SIZE - CITY_SIZE / 2) * TILE_SIZE;
            } while (x < -100 && z < -100);
            g.position.set(x, 0, z);
            scene.add(g);
            pedestrians.push({ mesh: g, speed: 2 + Math.random() * 2, dir: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(), time: 0 });
        }
        function updatePedestrians(dt) {
            for (let i = pedestrians.length - 1; i >= 0; i--) {
                const p = pedestrians[i];
                if (p.dead) { p.mesh.position.y -= dt; if (p.mesh.position.y < -2) { scene.remove(p.mesh); pedestrians.splice(i, 1); } continue; }
                const next = p.mesh.position.clone().add(p.dir.clone().multiplyScalar(p.speed * dt));
                p.time -= dt;
                if (checkCollision(next) || p.time <= 0) { p.dir = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(); p.time = 2 + Math.random() * 3; }
                else { p.mesh.position.copy(next); p.mesh.lookAt(p.mesh.position.clone().add(p.dir)); }
            }
        }
        function updateBullets(dt) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.life -= dt; b.mesh.position.add(b.dir.clone().multiplyScalar(40 * dt));
                let hit = false;
                pedestrians.forEach(p => { if (!p.dead && b.mesh.position.distanceTo(p.mesh.position) < 1.5) { p.dead = true; p.mesh.rotation.z = Math.PI / 2; p.mesh.position.y = 0.5; hit = true; } });
                if (checkCollision(b.mesh.position)) hit = true;
                if (b.life <= 0 || hit) { scene.remove(b.mesh); bullets.splice(i, 1); }
            }
        }

        function checkCollision(pos) {
            const box = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(1, 1, 1));
            for (let b of buildings) if (box.intersectsBox(b)) return true;
            return false;
        }

        function updateCamera() {
            if (!gameState.cameraTarget) return;
            const target = gameState.cameraTarget.position.clone();
            if (gameState.inCar) {
                const off = new THREE.Vector3(0, 5, -12).applyAxisAngle(new THREE.Vector3(0, 1, 0), gameState.activeCar.mesh.rotation.y);
                camera.position.lerp(target.clone().add(off), 0.1);
            } else {
                const off = new THREE.Vector3(0, 4, -8).applyQuaternion(gameState.cameraTarget.quaternion);
                camera.position.lerp(target.clone().add(off), 0.1);
            }
            camera.lookAt(target.add(new THREE.Vector3(0, 2, 0)));
        }
        function checkInteractionPrompt() {
            const msg = document.getElementById('message');
            if (gameState.inCar) { msg.style.display = 'none'; return; }
            let near = false; cars.forEach(c => { if (player.mesh.position.distanceTo(c.mesh.position) < 5) near = true; });
            if (near) { msg.style.display = 'block'; msg.innerText = "Press 'F' to Steal Car"; msg.style.color = 'white'; }
            else msg.style.display = 'none';
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        init();
    </script>
</body>

</html>