<!DOCTYPE html>
<html>

<head>
    <title>3D Lane Runner - V3</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 1px 1px 3px #000000;
            display: none;
            /* Hidden until the game starts */
        }

        #score {
            font-size: 28px;
            font-weight: bold;
        }

        /* Common style for overlays (Game Over and Start Screen) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: Arial, sans-serif;
            color: white;
        }

        #gameOver {
            display: none;
            /* Hidden by default */
            background-color: rgba(150, 0, 0, 0.8);
        }

        #startScreen {
            /* Displayed by default */
            background-color: rgba(5, 5, 5, 0.5);
            cursor: pointer;
            z-index: 10;
        }

        .overlayContent {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 30px 50px;
            border-radius: 15px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div id="score">Score: 0</div>
    </div>

    <div id="startScreen" class="overlay">
        <div class="overlayContent">
            <h1>3D Runner</h1>
            <h2>Click Anywhere to Start</h2>
            <p>Controls: Left/Right to Dodge, Up/Space to Jump</p>
        </div>
    </div>

    <div id="gameOver" class="overlay">
        <div class="overlayContent">
            <h1>Game Over!</h1>
            <p id="finalScore">Score: 0</p>
            <p>Press R to Restart</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Configuration ---
        const LANES = [-2, 0, 2];
        const START_SPEED = 1.75;
        const MAX_SPEED = 3;
        const SPEED_INCREASE_RATE = 0.00007;
        const OBSTACLE_SPAWN_DISTANCE = -10;
        const LERP_SPEED = 0.25;

        // Physics Constants
        const JUMP_VELOCITY = 0.28;
        const GRAVITY = 0.012;
        const GROUND_HEIGHT = 0.4;

        // --- Global Variables ---
        let scene, camera, renderer;
        let player;
        let obstacles = [];
        let score = 0;
        let gameSpeed = START_SPEED;

        // Game State
        let isGameOver = false;
        let isGameRunning = false; // Game starts paused

        let currentLane = 1;
        let obstacleTimer = 0;

        // Jump State
        let verticalVelocity = 0;
        let isOnGround = true;

        function init() {
            // Scene and Atmosphere
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 20, 70);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3.5, 7);
            camera.lookAt(0, 1.5, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x666666);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Ground (The Track)
            const groundGeometry = new THREE.PlaneGeometry(8, 200, 1, 1);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F }); // DarkOliveGreen
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Player (A simple Cube)
            const playerGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // Gold
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.y = GROUND_HEIGHT;
            player.position.x = LANES[currentLane];
            scene.add(player);

            // Event Listeners
            document.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('resize', onWindowResize, false);

            // Start Screen Listener
            document.getElementById('startScreen').addEventListener('click', startGame, false);
        }

        // --- Game State Management ---

        function startGame() {
            // Hide the start screen and show UI
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            // Start the game loop
            isGameRunning = true;
        }

        function gameOver() {
            isGameOver = true;
            isGameRunning = false;
            document.getElementById('finalScore').innerText = "Score: " + Math.floor(score);
            document.getElementById('gameOver').style.display = 'flex';
        }

        function resetGame() {
            // Hide UI
            isGameOver = false;
            document.getElementById('gameOver').style.display = 'none';

            // Reset variables
            score = 0;
            gameSpeed = START_SPEED;
            currentLane = 1;

            // Reset Player Position and Jump State
            player.position.x = LANES[currentLane];
            player.position.y = GROUND_HEIGHT;
            verticalVelocity = 0;
            isOnGround = true;

            obstacleTimer = 0;

            // Clear existing obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                scene.remove(obstacles[i]);
            }
            obstacles = [];

            // Start the game running again immediately
            isGameRunning = true;
        }


        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Only run game logic if the game is active
            if (isGameRunning) {

                // 1. Increase speed over time
                if (gameSpeed < MAX_SPEED) {
                    gameSpeed += SPEED_INCREASE_RATE;
                }

                // 2. Smooth Player Movement (Horizontal)
                player.position.x = THREE.MathUtils.lerp(player.position.x, LANES[currentLane], LERP_SPEED);

                // 3. Player Movement (Vertical - Jumping)
                updateJump();

                // 4. Obstacle Management
                moveObstacles();
                checkCollisions();

                // 5. Spawn Obstacles
                obstacleTimer += gameSpeed;
                // Adjust this threshold (e.g., 17) to change spawn frequency
                if (obstacleTimer > 17) {
                    spawnObstacle();
                    // Chance to spawn a second obstacle immediately
                    if (Math.random() > 0.7) {
                        spawnObstacle();
                    }
                    obstacleTimer = 0;
                }

                // 6. Update Score
                score += gameSpeed;
                document.getElementById('score').innerText = "Score: " + Math.floor(score);
            }

            // Keep rendering the scene even when paused, otherwise it freezes visually
            renderer.render(scene, camera);
        }

        // --- Mechanics ---

        function updateJump() {
            if (!isOnGround) {
                player.position.y += verticalVelocity;
                verticalVelocity -= GRAVITY;

                if (player.position.y <= GROUND_HEIGHT) {
                    player.position.y = GROUND_HEIGHT;
                    verticalVelocity = 0;
                    isOnGround = true;
                }
            }
        }

        function startJump() {
            if (isOnGround) {
                isOnGround = false;
                verticalVelocity = JUMP_VELOCITY;
            }
        }

        function onKeyDown(event) {
            // Handle restart independently of the game running state
            if (isGameOver) {
                if (event.keyCode == 82) { // R key
                    resetGame();
                }
                return;
            }

            // Only allow movement if the game is running
            if (!isGameRunning) return;

            if (event.keyCode == 37) { // Left arrow
                if (currentLane > 0) {
                    currentLane--;
                }
            } else if (event.keyCode == 39) { // Right arrow
                if (currentLane < LANES.length - 1) {
                    currentLane++;
                }
            } else if (event.keyCode == 38 || event.keyCode == 32) { // Up arrow or Spacebar
                startJump();
            }
        }

        function spawnObstacle() {
            // All obstacles are now standard size.
            const height = 1.2;
            const yPos = 0.6;

            const geometry = new THREE.BoxGeometry(1.2, height, 1.2);
            const material = new THREE.MeshStandardMaterial({ color: 0xDC143C }); // Crimson obstacles
            const obstacle = new THREE.Mesh(geometry, material);

            // Randomize lane
            const laneIndex = Math.floor(Math.random() * LANES.length);
            obstacle.position.x = LANES[laneIndex];
            obstacle.position.y = yPos;
            obstacle.position.z = OBSTACLE_SPAWN_DISTANCE;

            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function moveObstacles() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.z += gameSpeed;

                // Remove obstacles that have passed the camera
                if (obstacles[i].position.z > camera.position.z + 2) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }
        }

        function checkCollisions() {
            // Make hitbox slightly smaller for fairness
            const playerBox = new THREE.Box3().setFromObject(player).expandByScalar(-0.2);

            for (let i = 0; i < obstacles.length; i++) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacles[i]);

                if (playerBox.intersectsBox(obstacleBox)) {
                    gameOver();
                    return;
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize and start the game loop (the game logic will wait for startGame() to be called)
        init();
        animate();
    </script>
</body>

</html>