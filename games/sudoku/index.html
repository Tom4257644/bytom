<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Sudoku</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            touch-action: manipulation;
            /* Prevents double-tap zoom on buttons */
        }

        /* Custom Grid Borders for the 3x3 effect */
        .sudoku-cell {
            transition: all 0.1s ease;
        }

        /* Right border for every 3rd cell (3, 6) */
        .sudoku-cell:nth-child(3n):not(:nth-child(9n)) {
            border-right: 2px solid #374151;
            /* gray-700 */
        }

        /* Bottom border for every 3rd row (cells 19-27, 46-54) */
        .sudoku-grid>div:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid>div:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #374151;
        }

        /* Hover and Selection States */
        .cell-selected {
            background-color: #bfdbfe !important;
            /* blue-200 */
        }

        .cell-highlighted {
            background-color: #e5e7eb;
            /* gray-200 */
        }

        .cell-same-number {
            background-color: #c7d2fe;
            /* indigo-200 */
        }

        .cell-error {
            color: #ef4444;
            /* red-500 */
            background-color: #fecaca !important;
            /* red-200 */
        }

        .cell-fixed {
            color: #111827;
            /* gray-900 */
            font-weight: 700;
        }

        .cell-user {
            color: #2563eb;
            /* blue-600 */
            font-weight: 500;
        }

        /* Animation for numbers appearing */
        @keyframes popIn {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in {
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Modal Overlay */
        #modal-overlay.hidden {
            display: none;
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-center text-gray-800">

    <!-- Header & Controls -->
    <div class="w-full max-w-md px-4 mb-4 flex flex-col items-center">
        <h1 class="text-3xl font-bold text-indigo-700 mb-4">Sudoku</h1>

        <div class="flex justify-between w-full mb-4 text-sm font-semibold text-gray-600">
            <div class="flex items-center gap-2">
                <span>Difficulty:</span>
                <select id="difficulty-select"
                    class="bg-white border border-gray-300 rounded px-2 py-1 focus:outline-none focus:border-indigo-500">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            <div class="flex items-center gap-4">
                <div id="mistakes-counter" class="text-red-500">Mistakes: 0/3</div>
                <div id="timer" class="font-mono text-gray-800">00:00</div>
            </div>
        </div>
    </div>

    <!-- Game Board -->
    <div class="bg-white p-1 rounded-lg shadow-xl border border-gray-800 mb-6">
        <div id="sudoku-grid"
            class="sudoku-grid grid grid-cols-9 bg-gray-800 border-2 border-gray-800 w-[320px] h-[320px] sm:w-[400px] sm:h-[400px] md:w-[450px] md:h-[450px]">
            <!-- Cells generated by JS -->
        </div>
    </div>

    <!-- Number Pad -->
    <div class="w-full max-w-md px-4 grid grid-cols-9 gap-1 sm:gap-2 mb-6">
        <!-- Buttons 1-9 generated by JS -->
    </div>

    <!-- Action Buttons -->
    <div class="flex gap-4">
        <button id="new-game-btn"
            class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full font-semibold shadow transition-colors">
            New Game
        </button>
    </div>

    <!-- Win/Loss Modal -->
    <div id="modal-overlay"
        class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden backdrop-blur-sm">
        <div class="bg-white rounded-xl shadow-2xl p-8 max-w-sm w-full text-center transform transition-all scale-100">
            <div id="modal-icon" class="text-5xl mb-4">üèÜ</div>
            <h2 id="modal-title" class="text-2xl font-bold mb-2 text-gray-800">Solved!</h2>
            <p id="modal-message" class="text-gray-600 mb-6">Great job completing the puzzle.</p>
            <button onclick="startNewGame()"
                class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-semibold transition-colors">
                Play Again
            </button>
        </div>
    </div>

    <script>
        // --- Game State ---
        let solution = [];
        let board = [];
        let initialBoard = [];
        let selectedCellIndex = -1;
        let mistakes = 0;
        let timerInterval;
        let secondsElapsed = 0;
        let gameActive = false;

        const gridElement = document.getElementById('sudoku-grid');
        const numpadElement = document.querySelector('.w-full.max-w-md.grid'); // Select grid container for numpad
        const mistakesElement = document.getElementById('mistakes-counter');
        const timerElement = document.getElementById('timer');
        const modal = document.getElementById('modal-overlay');
        const difficultySelect = document.getElementById('difficulty-select');

        // --- Initialization ---

        function init() {
            createGrid();
            createNumpad();
            startNewGame();

            // Keyboard support
            document.addEventListener('keydown', (e) => {
                if (!gameActive) return;

                const key = e.key;
                if (key >= '1' && key <= '9') {
                    handleNumberInput(parseInt(key));
                } else if (key === 'Backspace' || key === 'Delete') {
                    handleNumberInput(0); // 0 clears the cell
                } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
                    moveSelection(key);
                }
            });

            document.getElementById('new-game-btn').addEventListener('click', startNewGame);
        }

        function createGrid() {
            gridElement.innerHTML = '';
            for (let i = 0; i < 81; i++) {
                const cell = document.createElement('div');
                cell.classList.add(
                    'bg-white', 'flex', 'items-center', 'justify-center',
                    'text-xl', 'sm:text-2xl', 'cursor-pointer', 'select-none',
                    'border', 'border-gray-200', 'sudoku-cell'
                );
                cell.dataset.index = i;
                cell.addEventListener('click', () => selectCell(i));
                gridElement.appendChild(cell);
            }
        }

        function createNumpad() {
            numpadElement.innerHTML = '';
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.classList.add(
                    'h-10', 'sm:h-12', 'bg-white', 'border', 'border-gray-300',
                    'rounded', 'text-indigo-600', 'font-bold', 'text-lg',
                    'hover:bg-indigo-50', 'active:bg-indigo-100', 'transition-colors'
                );
                btn.addEventListener('click', () => handleNumberInput(i));
                numpadElement.appendChild(btn);
            }
        }

        // --- Game Logic: Generation ---

        function startNewGame() {
            // Reset state
            gameActive = true;
            mistakes = 0;
            secondsElapsed = 0;
            selectedCellIndex = -1;
            modal.classList.add('hidden');
            updateMistakes();
            startTimer();

            // Generate Board
            generateSudoku();

            // Render
            renderBoard();
        }

        function generateSudoku() {
            // 1. Create empty 9x9 board
            solution = Array(81).fill(0);

            // 2. Fill diagonal 3x3 matrices (independent, so safe to randomize)
            fillDiagonal();

            // 3. Fill remaining blocks using backtracking
            solveSudoku(solution);

            // 4. Remove digits to create puzzle
            board = [...solution];
            let attempts = 5;

            const difficulty = difficultySelect.value;
            let holes = 30; // default easy
            if (difficulty === 'medium') holes = 40;
            if (difficulty === 'hard') holes = 50;

            while (holes > 0) {
                let idx = Math.floor(Math.random() * 81);
                if (board[idx] !== 0) {
                    board[idx] = 0;
                    holes--;
                }
            }

            initialBoard = [...board];
        }

        function fillDiagonal() {
            for (let i = 0; i < 9; i = i + 3) {
                fillBox(i, i);
            }
        }

        function fillBox(row, col) {
            let num;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    do {
                        num = Math.floor(Math.random() * 9) + 1;
                    } while (!isSafeInBox(row, col, num));

                    let idx = (row + i) * 9 + (col + j);
                    solution[idx] = num;
                }
            }
        }

        function isSafeInBox(rowStart, colStart, num) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    let r = rowStart + i;
                    let c = colStart + j;
                    if (solution[r * 9 + c] === num) return false;
                }
            }
            return true;
        }

        function isSafe(grid, row, col, num) {
            // Check row
            for (let x = 0; x < 9; x++) {
                if (grid[row * 9 + x] === num) return false;
            }
            // Check col
            for (let x = 0; x < 9; x++) {
                if (grid[x * 9 + col] === num) return false;
            }
            // Check box
            let startRow = row - row % 3;
            let startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[(startRow + i) * 9 + (startCol + j)] === num) return false;
                }
            }
            return true;
        }

        function solveSudoku(grid) {
            let row = -1;
            let col = -1;
            let isEmpty = false;

            for (let i = 0; i < 81; i++) {
                if (grid[i] === 0) {
                    row = Math.floor(i / 9);
                    col = i % 9;
                    isEmpty = true;
                    break;
                }
            }

            if (!isEmpty) return true; // Solved

            // Try numbers 1-9
            for (let num = 1; num <= 9; num++) {
                if (isSafe(grid, row, col, num)) {
                    grid[row * 9 + col] = num;
                    if (solveSudoku(grid)) return true;
                    grid[row * 9 + col] = 0; // Backtrack
                }
            }
            return false;
        }

        // --- Interaction & Rendering ---

        function renderBoard() {
            const cells = gridElement.children;
            for (let i = 0; i < 81; i++) {
                const cell = cells[i];
                const val = board[i];

                // Clear previous classes
                cell.className = 'bg-white flex items-center justify-center text-xl sm:text-2xl cursor-pointer select-none border border-gray-200 sudoku-cell';

                if (val !== 0) {
                    cell.textContent = val;
                    if (initialBoard[i] !== 0) {
                        cell.classList.add('cell-fixed');
                    } else {
                        cell.classList.add('cell-user', 'pop-in');
                    }
                } else {
                    cell.textContent = '';
                }
            }
        }

        function selectCell(index) {
            if (!gameActive) return;
            selectedCellIndex = index;
            highlightBoard();
        }

        function highlightBoard() {
            if (selectedCellIndex === -1) return;

            const cells = gridElement.children;
            const selectedVal = board[selectedCellIndex];
            const row = Math.floor(selectedCellIndex / 9);
            const col = selectedCellIndex % 9;
            const boxStartRow = row - (row % 3);
            const boxStartCol = col - (col % 3);

            for (let i = 0; i < 81; i++) {
                const cell = cells[i];
                const r = Math.floor(i / 9);
                const c = i % 9;

                // Reset Highlight
                cell.classList.remove('cell-selected', 'cell-highlighted', 'cell-same-number');

                // 1. Highlight Same Number
                if (selectedVal !== 0 && board[i] === selectedVal) {
                    cell.classList.add('cell-same-number');
                }

                // 2. Highlight Row, Col, Box
                else if (r === row || c === col ||
                    (r >= boxStartRow && r < boxStartRow + 3 && c >= boxStartCol && c < boxStartCol + 3)) {
                    cell.classList.add('cell-highlighted');
                }
            }

            // 3. Highlight Selected Cell specific
            cells[selectedCellIndex].classList.add('cell-selected');
            cells[selectedCellIndex].classList.remove('cell-highlighted'); // Override
        }

        function handleNumberInput(num) {
            if (!gameActive || selectedCellIndex === -1) return;

            // Cannot edit fixed initial numbers
            if (initialBoard[selectedCellIndex] !== 0) return;

            const cell = gridElement.children[selectedCellIndex];

            // Clearing the cell
            if (num === 0) {
                board[selectedCellIndex] = 0;
                cell.textContent = '';
                cell.classList.remove('cell-user', 'cell-error');
                highlightBoard();
                return;
            }

            // Enter Number
            board[selectedCellIndex] = num;
            cell.textContent = num;
            cell.classList.add('cell-user', 'pop-in');

            // Check Validity
            if (num !== solution[selectedCellIndex]) {
                cell.classList.add('cell-error');
                mistakes++;
                updateMistakes();

                if (mistakes >= 3) {
                    endGame(false);
                }
            } else {
                cell.classList.remove('cell-error');
                checkWin();
            }

            highlightBoard();
        }

        function moveSelection(key) {
            if (selectedCellIndex === -1) {
                selectCell(0);
                return;
            }

            let row = Math.floor(selectedCellIndex / 9);
            let col = selectedCellIndex % 9;

            if (key === 'ArrowUp') row = Math.max(0, row - 1);
            if (key === 'ArrowDown') row = Math.min(8, row + 1);
            if (key === 'ArrowLeft') col = Math.max(0, col - 1);
            if (key === 'ArrowRight') col = Math.min(8, col + 1);

            selectCell(row * 9 + col);
        }

        function updateMistakes() {
            mistakesElement.textContent = `Mistakes: ${mistakes}/3`;
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                secondsElapsed++;
                const mins = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
                const secs = (secondsElapsed % 60).toString().padStart(2, '0');
                timerElement.textContent = `${mins}:${secs}`;
            }, 1000);
        }

        function checkWin() {
            // If any cell is 0 or error, not won
            for (let i = 0; i < 81; i++) {
                if (board[i] === 0 || board[i] !== solution[i]) return;
            }
            endGame(true);
        }

        function endGame(won) {
            gameActive = false;
            clearInterval(timerInterval);
            modal.classList.remove('hidden');

            const title = document.getElementById('modal-title');
            const icon = document.getElementById('modal-icon');
            const msg = document.getElementById('modal-message');

            if (won) {
                icon.textContent = 'üèÜ';
                title.textContent = 'Solved!';
                msg.textContent = `You finished the ${difficultySelect.value} puzzle in ${timerElement.textContent}.`;
            } else {
                icon.textContent = 'üòî';
                title.textContent = 'Game Over';
                msg.textContent = 'You made 3 mistakes. Try again!';
            }
        }

        // Initialize on load
        window.onload = init;

    </script>
</body>

</html>