<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Racing - Varied Forest</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            user-select: none;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #laps {
            font-size: 30px;
        }

        #timer {
            font-size: 40px;
            font-family: 'Courier New', monospace;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 8px;
            border: 2px solid #555;
            width: fit-content;
        }

        #coords {
            font-size: 16px;
            font-family: 'Courier New', monospace;
            color: #ffff00;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid #444;
            width: fit-content;
        }

        #live-leaderboard {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            width: 220px;
            margin-top: 10px;
            font-family: 'Arial', sans-serif;
        }

        .lb-header {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 5px;
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
            display: flex;
            justify-content: space-between;
        }

        .lb-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .lb-row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #ccc;
            padding: 2px 0;
        }

        .lb-pos {
            width: 25px;
            text-align: left;
            font-weight: bold;
            color: #fff;
        }

        .lb-name {
            flex-grow: 1;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lb-row.is-player {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            background: rgba(0, 255, 0, 0.1);
        }

        #lights-overlay {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #555;
        }

        .light-bulb {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #222;
            border: 2px solid #000;
            box-shadow: inset 0 0 10px #000;
            transition: background 0.1s, box-shadow 0.1s;
        }

        .light-bulb.red {
            background: #ff0000;
            box-shadow: 0 0 20px #ff0000, inset 0 0 5px #500;
        }

        .light-bulb.green {
            background: #00ff00;
            box-shadow: 0 0 30px #00ff00, inset 0 0 5px #050;
        }

        #fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2.5s ease-in;
            z-index: 50;
        }

        #results-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #results-screen::-webkit-scrollbar {
            width: 8px;
        }

        #results-screen::-webkit-scrollbar-track {
            background: #222;
        }

        #results-screen::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        #placing-text {
            font-size: 80px;
            font-weight: 900;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .gold {
            color: #FFD700;
        }

        .silver {
            color: #C0C0C0;
        }

        .bronze {
            color: #CD7F32;
        }

        .participant {
            color: #fff;
        }

        .dnf {
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
        }

        #leaderboard {
            width: 100%;
            border-collapse: collapse;
            background: rgba(20, 20, 20, 0.9);
            color: white;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #444;
        }

        #leaderboard th,
        #leaderboard td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #333;
            font-size: 16px;
        }

        #leaderboard th {
            background: #333;
        }

        .player-row {
            background: rgba(0, 255, 0, 0.2);
        }

        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            border-radius: 8px;
            z-index: 10;
        }

        canvas#minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        #hud-right {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            z-index: 10;
        }

        .status-bar-container {
            width: 150px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
        }

        .bar-label {
            color: #ccc;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .bar-track {
            width: 100%;
            height: 6px;
            background: #333;
        }

        #damage-bar {
            height: 100%;
            width: 0%;
            background: #ff3333;
            transition: width 0.1s;
        }

        #wear-bar {
            height: 100%;
            width: 0%;
            background: #ffcc00;
            transition: width 0.1s;
        }

        #speed-container {
            width: 180px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 10px;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            text-align: right;
        }

        #speed-value {
            font-size: 40px;
            font-weight: bold;
            color: #00ff00;
        }

        #speed-unit {
            font-size: 14px;
            color: #aaa;
        }

        #rpm-bar-bg {
            width: 100%;
            height: 8px;
            background: #333;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
        }

        #rpm-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.1s;
        }

        #grass-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333;
            font-size: 40px;
            font-weight: bold;
            display: none;
            pointer-events: none;
            border: 4px solid red;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            z-index: 5;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>

<body>

    <div id="ui-container">
        <div id="laps" class="hud-panel">LAP <span id="lap-counter">1</span> / 2</div>
        <div id="timer" class="hud-panel">00:00.00</div>
        <div id="coords" class="hud-panel">X: 0 Y: 0 Z: 0</div>

        <div id="live-leaderboard">
            <div class="lb-header"><span>POS</span><span>DRIVER</span></div>
            <div id="lb-list" class="lb-list"></div>
        </div>
    </div>

    <div id="lights-overlay">
        <div id="light-1" class="light-bulb"></div>
        <div id="light-2" class="light-bulb"></div>
        <div id="light-3" class="light-bulb"></div>
    </div>

    <div id="grass-warning">OFF TRACK!</div>

    <div id="fade-overlay"></div>
    <div id="results-screen">
        <div id="placing-text">FINISH</div>
        <table id="leaderboard">
            <thead>
                <tr>
                    <th>Pos</th>
                    <th>Driver</th>
                    <th>Time</th>
                </tr>
            </thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
        <div style="margin-top:20px; color:#aaa; font-size:14px;">Refresh page to race again</div>
    </div>

    <div id="minimap-container"><canvas id="minimap" width="200" height="200"></canvas></div>

    <div id="hud-right">
        <div class="status-bar-container">
            <div class="bar-label">VEHICLE DAMAGE</div>
            <div class="bar-track">
                <div id="damage-bar"></div>
            </div>
        </div>
        <div class="status-bar-container">
            <div class="bar-label">TIRE WEAR</div>
            <div class="bar-track">
                <div id="wear-bar"></div>
            </div>
        </div>

        <div id="speed-container">
            <span id="speed-value">0</span> <span id="speed-unit">MPH</span>
            <div id="rpm-bar-bg">
                <div id="rpm-bar-fill"></div>
            </div>
        </div>
    </div>

    <div id="controls-hint">Controls: W (Gas), S (Brake), A/D (Steer)</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- DRIVER DATA ---
        const DRIVER_DATA = [
            { "name": "Maxx Verstappen", "team": "Red Bull Racing", "number": 1 },
            { "name": "Liamn Lawson", "team": "Red Bull Racing", "number": 30 },
            { "name": "Landoe Norris", "team": "McLaren", "number": 4 },
            { "name": "Oscarr Piastri", "team": "McLaren", "number": 81 },
            { "name": "Charlse Leclerc", "team": "Ferrari", "number": 16 },
            { "name": "Lewes Hamilton", "team": "Ferrari", "number": 44 },
            { "name": "Georg Russell", "team": "Mercedes", "number": 63 },
            { "name": "Andreo Antonelli", "team": "Mercedes", "number": 12 },
            { "name": "Fernan Alonso", "team": "Aston Martin", "number": 14 },
            { "name": "Lancen Stroll", "team": "Aston Martin", "number": 18 },
            { "name": "Pierro Gasly", "team": "Alpine", "number": 10 },
            { "name": "Jacke Doohan", "team": "Alpine", "number": 61 },
            { "name": "Estebn Ocon", "team": "Haas", "number": 31 },
            { "name": "Olliver Bearman", "team": "Haas", "number": 87 },
            { "name": "Yukio Tsunoda", "team": "Racing Bulls", "number": 22 },
            { "name": "Isackk Hadjar", "team": "Racing Bulls", "number": 6 },
            { "name": "Alexz Albon", "team": "Williams", "number": 23 },
            { "name": "Carloss Sainz", "team": "Williams", "number": 55 },
            { "name": "Nicoo Hulkenberg", "team": "Kick Sauber", "number": 27 },
            { "name": "Gabrielo Bortoleto", "team": "Kick Sauber", "number": 5 }
        ];

        // --- TEAM HEX COLORS ---
        const TEAM_COLORS = {
            "Red Bull Racing": 0x3671C6,
            "McLaren": 0xFF8000,
            "Ferrari": 0xF91536,
            "Mercedes": 0x6CD3BF,
            "Aston Martin": 0x229971,
            "Alpine": 0x0093CC,
            "Haas": 0xB6BABD, // White/Grey
            "Racing Bulls": 0x6692FF,
            "Williams": 0x64C4FF,
            "Kick Sauber": 0x52E252
        };

        // --- SETTINGS ---
        const PLAYER_START_POS = 20;
        const KMH_FACTOR = 200;
        const CAR_ACCEL = 0.1;
        const CAR_MAX_SPEED = 1;
        const CAR_TURN_SPEED = 0.085;
        const CAR_FRICTION_ROAD = 0.99;
        const CAR_FRICTION_GRASS = 0.75;
        const TRACK_RADIUS = 14;
        const PIT_LANE_RADIUS = 10;
        const CAMERA_HEIGHT = 7;
        const CAMERA_DISTANCE = 10;
        const TOTAL_LAPS = 2;
        const GRID_START_OFFSET = 15;

        // --- Globals ---
        let scene, camera, renderer;
        let car, aiCars = [];
        let trackCurve, pitLaneCurve;
        let keys = { w: false, a: false, s: false, d: false };

        let speed = 0;
        let angle = Math.PI;
        let velocity = new THREE.Vector3();
        let onGrass = false;
        let inPitLane = false;

        let playerDamage = 0;
        let playerTireWear = 0;
        let isDNF = false;
        let raceStarted = false;

        let currentLap = 0;
        let lastCheckpoint = -1;
        let totalCheckpoints = 2000;
        let playerFinished = false;
        let startTime = 0;
        let totalTrackLength = 0;
        let playerDriverName = "YOU";

        let finishedCars = 0;
        let rankings = [];

        // UI References
        const mapCanvas = document.getElementById('minimap');
        const mapCtx = mapCanvas.getContext('2d');
        const speedValueEl = document.getElementById('speed-value');
        const rpmBarEl = document.getElementById('rpm-bar-fill');
        const grassWarningEl = document.getElementById('grass-warning');
        const timerEl = document.getElementById('timer');
        const lapEl = document.getElementById('lap-counter');
        const coordsEl = document.getElementById('coords');
        const fadeOverlay = document.getElementById('fade-overlay');
        const resultsScreen = document.getElementById('results-screen');
        const placingText = document.getElementById('placing-text');
        const boardBody = document.getElementById('leaderboard-body');
        const damageBarEl = document.getElementById('damage-bar');
        const wearBarEl = document.getElementById('wear-bar');
        const lbListEl = document.getElementById('lb-list');
        const lightsOverlay = document.getElementById('lights-overlay');
        const light1 = document.getElementById('light-1');
        const light2 = document.getElementById('light-2');
        const light3 = document.getElementById('light-3');

        let trackPoints2D = [];
        let pitLanePointsCollision = [];
        let lastLBUpdate = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 200, 3000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(1000, 1500, 500);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 4000;
            const shadowSize = 3000;
            dirLight.shadow.camera.left = -shadowSize;
            dirLight.shadow.camera.right = shadowSize;
            dirLight.shadow.camera.top = shadowSize;
            dirLight.shadow.camera.bottom = -shadowSize;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            createGround();
            createTrack();
            createPitLane();
            createStartLine();
            createTrees(); // Create Trees

            // --- SPAWNING LOGIC ---
            const totalCars = 20;
            const rowSpacing = 12;
            const sideSpacing = 5;

            for (let i = 0; i < totalCars; i++) {
                const gridPos = i + 1;

                const driverInfo = DRIVER_DATA[i % DRIVER_DATA.length];
                const teamColor = TEAM_COLORS[driverInfo.team] || 0xFFFFFF;

                const row = Math.floor(i / 2);
                const isRightSide = (i % 2 !== 0);

                const backwardDist = GRID_START_OFFSET + (row * rowSpacing);

                let progress = (totalTrackLength - backwardDist) / totalTrackLength;
                if (progress < 0) progress += 1;

                const pt = trackCurve.getPointAt(progress);
                const tangent = trackCurve.getTangentAt(progress).normalize();
                const right = tangent.clone().cross(new THREE.Vector3(0, 1, 0)).normalize();

                const sideDist = isRightSide ? sideSpacing : -sideSpacing;
                const finalPos = pt.clone().add(right.multiplyScalar(sideDist));

                const lookTarget = finalPos.clone().add(tangent);

                if (gridPos === PLAYER_START_POS) {
                    playerDriverName = driverInfo.name;
                    createCar(finalPos, teamColor);
                    car.lookAt(lookTarget);
                    angle = Math.atan2(tangent.x, tangent.z);
                } else {
                    const skillFactor = 0.94 + (Math.random() * 0.08);
                    const aiMaxSpeed = CAR_MAX_SPEED * skillFactor;
                    const aiBaseAccel = CAR_ACCEL * skillFactor;

                    const mesh = createAICar(driverInfo.name, finalPos, teamColor, aiMaxSpeed, aiBaseAccel, progress);
                    mesh.lookAt(lookTarget);
                }
            }

            runCountdown();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));
        }

        // --- UPDATED: VARIED & SHORTER TREES ---
        function createTrees() {
            const totalTrees = 12000;
            const spread = 5000;
            const pineCount = Math.floor(totalTrees / 2);
            const oakCount = totalTrees - pineCount;

            // --- TYPE 1: PINE (Darker, Conical, Shorter than before) ---
            // Trunk: Height 6, sits at Y=3
            const pineTrunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 6, 6);
            pineTrunkGeo.translate(0, 3, 0);
            const pineTrunkMat = new THREE.MeshStandardMaterial({ color: 0x2d1e11, roughness: 1.0 });
            const pineTrunkMesh = new THREE.InstancedMesh(pineTrunkGeo, pineTrunkMat, pineCount);
            pineTrunkMesh.castShadow = true; pineTrunkMesh.receiveShadow = true;

            // Foliage: Height 12, sits on top of trunk at Y=3+6=9
            const pineFoliageGeo = new THREE.ConeGeometry(3, 12, 7);
            pineFoliageGeo.translate(0, 9, 0);
            const pineFoliageMat = new THREE.MeshStandardMaterial({ color: 0x1a401a, roughness: 0.9 });
            const pineFoliageMesh = new THREE.InstancedMesh(pineFoliageGeo, pineFoliageMat, pineCount);
            pineFoliageMesh.castShadow = true; pineFoliageMesh.receiveShadow = true;


            // --- TYPE 2: OAK/BROADLEAF (Lighter, Rounder, Short) ---
            // Trunk: Height 4, Thicker, sits at Y=2
            const oakTrunkGeo = new THREE.CylinderGeometry(0.6, 0.8, 4, 8);
            oakTrunkGeo.translate(0, 2, 0);
            const oakTrunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 1.0 });
            const oakTrunkMesh = new THREE.InstancedMesh(oakTrunkGeo, oakTrunkMat, oakCount);
            oakTrunkMesh.castShadow = true; oakTrunkMesh.receiveShadow = true;

            // Foliage: Dodecahedron (bushy), Radius 4, sits at Y=2+3.5=5.5
            const oakFoliageGeo = new THREE.DodecahedronGeometry(4, 0);
            oakFoliageGeo.translate(0, 5.5, 0);
            const oakFoliageMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
            const oakFoliageMesh = new THREE.InstancedMesh(oakFoliageGeo, oakFoliageMat, oakCount);
            oakFoliageMesh.castShadow = true; oakFoliageMesh.receiveShadow = true;


            const dummy = new THREE.Object3D();
            let pCount = 0;
            let oCount = 0;

            const trackPoints = trackCurve.getSpacedPoints(400);
            const pitPoints = pitLanePointsCollision || [];

            for (let i = 0; i < 50000; i++) {
                if (pCount + oCount >= totalTrees) break;

                const x = (Math.random() - 0.5) * spread * 2;
                const z = (Math.random() - 0.5) * spread * 2;

                let safe = true;
                for (let p of trackPoints) {
                    if ((p.x - x) ** 2 + (p.z - z) ** 2 < 576) { safe = false; break; }
                }
                if (!safe) continue;
                for (let p of pitPoints) {
                    if ((p.x - x) ** 2 + (p.z - z) ** 2 < 225) { safe = false; break; }
                }
                if (!safe) continue;

                dummy.position.set(x, 0, z);
                dummy.rotation.y = Math.random() * Math.PI * 2;

                // Randomly decide tree type
                if (Math.random() > 0.5 && pCount < pineCount) {
                    // PINE
                    const scale = 0.8 + Math.random() * 0.5; // Scale 0.8x to 1.3x
                    dummy.scale.set(scale, scale, scale);
                    dummy.updateMatrix();
                    pineTrunkMesh.setMatrixAt(pCount, dummy.matrix);
                    pineFoliageMesh.setMatrixAt(pCount, dummy.matrix);
                    pCount++;
                } else if (oCount < oakCount) {
                    // OAK
                    const scale = 0.8 + Math.random() * 0.4; // Scale 0.8x to 1.2x
                    dummy.scale.set(scale, scale, scale);
                    dummy.updateMatrix();
                    oakTrunkMesh.setMatrixAt(oCount, dummy.matrix);
                    oakFoliageMesh.setMatrixAt(oCount, dummy.matrix);
                    oCount++;
                }
            }

            scene.add(pineTrunkMesh); scene.add(pineFoliageMesh);
            scene.add(oakTrunkMesh); scene.add(oakFoliageMesh);
        }

        function runCountdown() {
            setTimeout(() => { light1.classList.add('red'); }, 1000);
            setTimeout(() => { light2.classList.add('red'); }, 2000);
            setTimeout(() => { light3.classList.add('red'); }, 3000);
            setTimeout(() => {
                light1.className = 'light-bulb green';
                light2.className = 'light-bulb green';
                light3.className = 'light-bulb green';
                raceStarted = true;
                startTime = Date.now();
            }, 4000);
            setTimeout(() => { lightsOverlay.style.display = 'none'; }, 5500);
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(10000, 10000);
            const material = new THREE.MeshStandardMaterial({ color: 0x3b593b });
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        function createTrack() {
            trackCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -400),
                new THREE.Vector3(-300, 0, -800),
                new THREE.Vector3(-800, 0, -600),
                new THREE.Vector3(-1200, 0, -800),
                new THREE.Vector3(-1800, 0, -400),
                new THREE.Vector3(-1800, 0, 400),
                new THREE.Vector3(-1400, 0, 800),
                new THREE.Vector3(-1000, 0, 400),
                new THREE.Vector3(-600, 0, 1000),
                new THREE.Vector3(-200, 0, 1400),
                new THREE.Vector3(400, 0, 1400),
                new THREE.Vector3(800, 0, 1000),
                new THREE.Vector3(1200, 0, 400),
                new THREE.Vector3(1600, 0, 0),
                new THREE.Vector3(1200, 0, -600),
                new THREE.Vector3(800, 0, -800),
                new THREE.Vector3(400, 0, -400),
            ], true);
            totalTrackLength = trackCurve.getLength();

            const points = trackCurve.getPoints(1500);
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            points.forEach(p => {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.z < minZ) minZ = p.z; if (p.z > maxZ) maxZ = p.z;
            });
            trackPoints2D = points.map(p => ({
                x: (p.x - minX) / (maxX - minX),
                y: (p.z - minZ) / (maxZ - minZ),
                bounds: { minX, maxX, minZ, maxZ }
            }));

            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#3a3a3a';
            for (let i = 0; i < 200; i++) ctx.fillRect(Math.random() * 128, Math.random() * 128, 2, 2);
            const asphaltTexture = new THREE.CanvasTexture(canvas);
            asphaltTexture.wrapS = THREE.RepeatWrapping;
            asphaltTexture.wrapT = THREE.RepeatWrapping;
            asphaltTexture.repeat.set(1500, 1);

            const tubeGeo = new THREE.TubeGeometry(trackCurve, 3000, TRACK_RADIUS, 8, true);
            const mesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ map: asphaltTexture, side: THREE.DoubleSide, roughness: 0.8 }));
            mesh.scale.y = 0.05; mesh.position.y = 0.1; mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createPitLane() {
            const pitLaneCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(400, 0, -400),
                new THREE.Vector3(200, 0, -300),
                new THREE.Vector3(0, 0, -400),
            ], false);

            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#555555'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 2, 64); ctx.fillRect(62, 0, 2, 64);
            const pitTexture = new THREE.CanvasTexture(canvas);
            pitTexture.wrapS = THREE.RepeatWrapping; pitTexture.wrapT = THREE.RepeatWrapping;
            pitTexture.repeat.set(50, 1);

            const tubeGeo = new THREE.TubeGeometry(pitLaneCurve, 200, PIT_LANE_RADIUS, 8, false);
            const mesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ map: pitTexture, side: THREE.DoubleSide, roughness: 0.9 }));
            mesh.scale.y = 0.05; mesh.position.y = 0.11;
            mesh.receiveShadow = true;
            scene.add(mesh);

            pitLanePointsCollision = pitLaneCurve.getSpacedPoints(200);

            const fontCanvas = document.createElement('canvas');
            fontCanvas.width = 128; fontCanvas.height = 64;
            const fCtx = fontCanvas.getContext('2d');
            fCtx.fillStyle = 'black'; fCtx.fillRect(0, 0, 128, 64);
            fCtx.fillStyle = 'yellow'; fCtx.font = 'bold 40px Arial'; fCtx.fillText("PIT", 30, 45);
            const signTex = new THREE.CanvasTexture(fontCanvas);
            const signGeo = new THREE.PlaneGeometry(10, 5);
            const signMat = new THREE.MeshBasicMaterial({ map: signTex });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.set(413, 10, -433);
            sign.lookAt(513, 10, -423);
            scene.add(sign);
        }

        function createStartLine() {
            const point = trackCurve.getPointAt(0);
            const tangent = trackCurve.getTangentAt(0);
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 32, 32); ctx.fillRect(32, 32, 32, 32);
            const checkTexture = new THREE.CanvasTexture(canvas);
            checkTexture.wrapS = THREE.RepeatWrapping; checkTexture.wrapT = THREE.RepeatWrapping;
            checkTexture.repeat.set(8, 2); checkTexture.magFilter = THREE.NearestFilter;
            const geometry = new THREE.PlaneGeometry(TRACK_RADIUS * 2, 5);
            const material = new THREE.MeshBasicMaterial({ map: checkTexture, side: THREE.DoubleSide, polygonOffset: true, polygonOffsetFactor: -2 });
            const line = new THREE.Mesh(geometry, material);
            line.position.copy(point); line.position.y = 0.2;
            const rotY = Math.atan2(tangent.x, tangent.z);
            line.rotation.set(-Math.PI / 2, 0, rotY, 'YXZ');
            scene.add(line);
        }

        function getCarMesh(colorHex) {
            const carGroup = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.2, metalness: 0.4 });
            const carbonMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
            const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1 });

            const chassisGeo = new THREE.BoxGeometry(0.6, 0.4, 4.2);
            const chassis = new THREE.Mesh(chassisGeo, bodyMat);
            chassis.position.set(0, 1.5, 0);
            chassis.castShadow = true;
            carGroup.add(chassis);

            const cockpitGeo = new THREE.BoxGeometry(0.62, 0.3, 0.8);
            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
            cockpit.position.set(0, 1.7, -0.2);
            carGroup.add(cockpit);

            const sidepodGeo = new THREE.BoxGeometry(0.4, 0.35, 1.8);
            const leftSidepod = new THREE.Mesh(sidepodGeo, bodyMat);
            leftSidepod.position.set(-0.5, 1.4, -0.3);
            carGroup.add(leftSidepod);

            const rightSidepod = new THREE.Mesh(sidepodGeo, bodyMat);
            rightSidepod.position.set(0.5, 1.4, -0.3);
            carGroup.add(rightSidepod);

            const fWingGeo = new THREE.BoxGeometry(1.8, 0.05, 0.5);
            const fWing = new THREE.Mesh(fWingGeo, carbonMat);
            fWing.position.set(0, 1.2, 2.1);
            carGroup.add(fWing);

            const rWingGeo = new THREE.BoxGeometry(1.6, 0.05, 0.5);
            const rWing = new THREE.Mesh(rWingGeo, carbonMat);
            rWing.position.set(0, 2.1, -2.0);
            carGroup.add(rWing);

            const pylonGeo = new THREE.BoxGeometry(0.1, 0.6, 0.4);
            const pylon = new THREE.Mesh(pylonGeo, carbonMat);
            pylon.position.set(0, 1.8, -2.0);
            carGroup.add(pylon);

            const airboxGeo = new THREE.BoxGeometry(0.3, 0.3, 0.4);
            const airbox = new THREE.Mesh(airboxGeo, bodyMat);
            airbox.position.set(0, 1.9, -0.4);
            carGroup.add(airbox);

            const wheelGeoFront = new THREE.CylinderGeometry(0.45, 0.45, 0.5, 32);
            const wheelGeoRear = new THREE.CylinderGeometry(0.48, 0.48, 0.7, 32);

            const positions = [
                { x: -0.85, z: 1.5, isFront: true },
                { x: 0.85, z: 1.5, isFront: true },
                { x: -0.85, z: -1.6, isFront: false },
                { x: 0.85, z: -1.6, isFront: false }
            ];

            positions.forEach(pos => {
                const geometry = pos.isFront ? wheelGeoFront : wheelGeoRear;
                const wheel = new THREE.Mesh(geometry, carbonMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 1.45, pos.z);
                wheel.castShadow = true;
                carGroup.add(wheel);

                const axleGeo = new THREE.BoxGeometry(Math.abs(pos.x), 0.05, 0.05);
                const axle = new THREE.Mesh(axleGeo, carbonMat);
                axle.position.set(pos.x / 2, 1.45, pos.z);
                carGroup.add(axle);
            });

            return carGroup;
        }

        function createCar(startPos, color) {
            car = getCarMesh(color);
            car.position.copy(startPos);
            scene.add(car);
        }

        function createAICar(name, startPos, color, maxSpeed, accel, startProgress) {
            const mesh = getCarMesh(color);
            mesh.position.copy(startPos);
            scene.add(mesh);
            aiCars.push({
                name: name,
                mesh: mesh,
                speed: 0,
                maxSpeed: maxSpeed,
                accel: accel,
                progress: startProgress,
                lap: 0,
                finished: false,
                laneBias: (Math.random() - 0.5) * 0.05,
                collisionPush: new THREE.Vector3(0, 0, 0)
            });
            return mesh;
        }

        function handleKey(e, isPressed) {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = isPressed;
            if (k === 's' || k === 'arrowdown') keys.s = isPressed;
            if (k === 'a' || k === 'arrowleft') keys.a = isPressed;
            if (k === 'd' || k === 'arrowright') keys.d = isPressed;
        }

        function getFormattedTime(msTime) {
            const m = Math.floor(msTime / 60000);
            const s = Math.floor((msTime % 60000) / 1000);
            const ms = Math.floor((msTime % 1000) / 10);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function triggerDNF() {
            isDNF = true;
            fadeOverlay.style.opacity = '1';
            setTimeout(() => {
                resultsScreen.style.display = 'block';
                placingText.innerText = "DNF";
                placingText.className = "dnf";
            }, 1000);
        }

        function registerFinish(name, time, isPlayer) {
            finishedCars++;
            rankings.push({ name: name, time: time, isPlayer: isPlayer });
            const tr = document.createElement('tr');
            if (isPlayer) tr.className = 'player-row';
            tr.innerHTML = `<td>${finishedCars}</td><td>${name}</td><td>${getFormattedTime(time)}</td>`;
            boardBody.appendChild(tr);

            if (isPlayer && !isDNF) {
                playerFinished = true;
                fadeOverlay.style.opacity = '1';
                setTimeout(() => {
                    resultsScreen.style.display = 'block';
                    let placeText = "";
                    let className = "participant";
                    if (finishedCars === 1) { placeText = "1ST PLACE"; className = "gold"; }
                    else if (finishedCars === 2) { placeText = "2ND PLACE"; className = "silver"; }
                    else if (finishedCars === 3) { placeText = "3RD PLACE"; className = "bronze"; }
                    else { placeText = finishedCars + "TH PLACE"; }
                    placingText.innerText = placeText;
                    placingText.className = className;
                }, 1000);
            }
        }

        function updateAI() {
            if (!raceStarted) return;

            aiCars.forEach(ai => {
                if (ai.finished) return;

                const lookAhead = 0.02;
                const tangent1 = trackCurve.getTangentAt(ai.progress).normalize();
                const tangent2 = trackCurve.getTangentAt((ai.progress + lookAhead) % 1).normalize();
                const dot = tangent1.dot(tangent2);
                let targetSpeed = ai.maxSpeed;

                if (dot < 0.98) {
                    targetSpeed = ai.maxSpeed * Math.max(0.95, dot * 0.5);
                }

                if (ai.speed > targetSpeed) {
                    ai.speed *= 0.97;
                } else {
                    if (ai.speed < ai.maxSpeed) ai.speed += ai.accel * 0.1;
                }

                ai.speed *= CAR_FRICTION_ROAD;

                const speedFactor = ai.speed / totalTrackLength;
                ai.progress += speedFactor;

                if (ai.progress > 1) {
                    ai.progress -= 1;
                    ai.lap++;
                    if (ai.lap > TOTAL_LAPS) {
                        ai.finished = true;
                        ai.speed = 0;
                        registerFinish(ai.name, Date.now() - startTime, false);
                        return;
                    }
                }

                const pt = trackCurve.getPointAt(ai.progress);
                ai.collisionPush.multiplyScalar(0.9);
                const tangent = trackCurve.getTangentAt(ai.progress).normalize();
                const normal = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();

                const laneOffset = binormal.clone().multiplyScalar(ai.laneBias * 300);
                ai.mesh.position.copy(pt).add(laneOffset).add(ai.collisionPush);

                const lookPt = trackCurve.getPointAt((ai.progress + 0.001) % 1);
                const lookOffset = new THREE.Vector3().crossVectors(trackCurve.getTangentAt((ai.progress + 0.001) % 1), normal).normalize().multiplyScalar(ai.laneBias * 300);
                ai.mesh.lookAt(lookPt.add(lookOffset).add(ai.collisionPush));
            });
        }

        function resolveCollision(pos1, radius1, pos2, radius2, isAi1, aiObj1) {
            const dx = pos1.x - pos2.x; const dz = pos1.z - pos2.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            const overlap = (radius1 + radius2) - dist;
            if (overlap > 0) {
                const nx = dx / dist; const nz = dz / dist;
                const pushX = nx * overlap * 0.5; const pushZ = nz * overlap * 0.5;
                pos1.x += pushX; pos1.z += pushZ;
                pos2.x -= pushX; pos2.z -= pushZ;
                if (isAi1 && aiObj1) {
                    aiObj1.collisionPush.x += pushX; aiObj1.collisionPush.z += pushZ;
                }
                return true;
            }
            return false;
        }

        function updatePhysics() {
            // Player Physics
            if (!playerFinished && !isDNF) {
                if (keys.w) speed += CAR_ACCEL * 0.1;
                if (keys.s) speed -= CAR_ACCEL * 0.2;
            } else {
                speed *= 0.98; // Coast
            }

            let effectiveSpeed = speed;
            if (!raceStarted) {
                effectiveSpeed = 0;
                if (speed > 0.2) speed = 0.2;
            } else {
                speed *= (onGrass ? CAR_FRICTION_GRASS : CAR_FRICTION_ROAD);
            }

            let currentMaxSpeed = CAR_MAX_SPEED;
            if (inPitLane) {
                currentMaxSpeed = 80 / KMH_FACTOR;
            }

            if (speed > currentMaxSpeed) speed = currentMaxSpeed;
            if (speed < -currentMaxSpeed / 2) speed = -currentMaxSpeed / 2;

            if (Math.abs(effectiveSpeed) > 0.01) {
                const speedRatio = Math.abs(effectiveSpeed) / CAR_MAX_SPEED;
                const sensitivity = Math.max(0.15, 1.0 - (speedRatio * 0.85));
                const turn = CAR_TURN_SPEED * sensitivity;

                if (!playerFinished && !isDNF) {
                    if (keys.a) {
                        angle += turn;
                        speed *= 0.995;
                        if (playerTireWear < 100) playerTireWear += 0.05;
                    }
                    if (keys.d) {
                        angle -= turn;
                        speed *= 0.995;
                        if (playerTireWear < 100) playerTireWear += 0.05;
                    }
                }
            }

            velocity.x = Math.sin(angle) * effectiveSpeed;
            velocity.z = Math.cos(angle) * effectiveSpeed;
            car.position.x += velocity.x;
            car.position.z += velocity.z;
            car.rotation.y = angle;

            // Collisions with AI
            const carRadius = 2.0;
            aiCars.forEach(ai => {
                const hit = resolveCollision(car.position, carRadius, ai.mesh.position, carRadius, false, null);
                if (hit) {
                    const dx = ai.mesh.position.x - car.position.x;
                    const dz = ai.mesh.position.z - car.position.z;
                    ai.collisionPush.x += dx * 0.1; ai.collisionPush.z += dz * 0.1;
                    speed *= 0.98;

                    if (playerDamage < 100 && !isDNF && !playerFinished && raceStarted) {
                        playerDamage += 0.4;
                        if (playerDamage >= 100) {
                            triggerDNF();
                        }
                    }
                }
            });
            for (let i = 0; i < aiCars.length; i++) {
                for (let j = i + 1; j < aiCars.length; j++) {
                    const ai1 = aiCars[i]; const ai2 = aiCars[j];
                    const hit = resolveCollision(ai1.mesh.position, carRadius, ai2.mesh.position, carRadius, true, ai1);
                    if (hit) {
                        const dx = ai2.mesh.position.x - ai1.mesh.position.x;
                        const dz = ai2.mesh.position.z - ai1.mesh.position.z;
                        ai2.collisionPush.x += dx * 0.1; ai2.collisionPush.z += dz * 0.1;
                    }
                }
            }

            // --- TRACK & PIT LANE DETECTION LOGIC ---

            const points = trackCurve.getSpacedPoints(totalCheckpoints);
            let closestDistMain = Infinity;
            let closestIndex = -1;
            for (let i = 0; i < points.length; i++) {
                const d = car.position.distanceTo(points[i]);
                if (d < closestDistMain) { closestDistMain = d; closestIndex = i; }
            }

            if (lastCheckpoint === -1) {
                lastCheckpoint = closestIndex;
            }

            let closestDistPit = Infinity;
            for (let i = 0; i < pitLanePointsCollision.length; i++) {
                const d = car.position.distanceTo(pitLanePointsCollision[i]);
                if (d < closestDistPit) closestDistPit = d;
            }

            const onMainTrack = closestDistMain <= TRACK_RADIUS + 1.5;
            const onPitLane = closestDistPit <= PIT_LANE_RADIUS + 1.0;

            if (onMainTrack || onPitLane) {
                onGrass = false;
            } else {
                onGrass = true;
            }

            inPitLane = onPitLane && !onMainTrack;
            if (inPitLane && Math.abs(speed) < 2.0 && !playerFinished && !isDNF) {
                if (playerDamage > 0) playerDamage -= 0.2;
                if (playerDamage < 0) playerDamage = 0;

                if (playerTireWear > 0) playerTireWear -= 0.2;
                if (playerTireWear < 0) playerTireWear = 0;
            }

            const buffer = 100;
            if (onMainTrack) {
                if (lastCheckpoint > totalCheckpoints - buffer && closestIndex < buffer) {
                    currentLap++;
                    lastCheckpoint = closestIndex;
                    if (!playerFinished && !isDNF) lapEl.innerText = Math.max(1, currentLap);

                    if (currentLap > TOTAL_LAPS && !playerFinished && !isDNF) {
                        lapEl.innerText = "FINISH";
                        registerFinish(playerDriverName, Date.now() - startTime, true);
                    }
                } else if (closestIndex > lastCheckpoint && closestIndex < lastCheckpoint + buffer) {
                    lastCheckpoint = closestIndex;
                }
            }
        }

        function updateHUD() {
            if (!playerFinished && !isDNF) {
                if (raceStarted) {
                    const now = Date.now();
                    timerEl.innerText = getFormattedTime(now - startTime);
                } else {
                    timerEl.innerText = "00:00.00";
                }
            }

            const kph = Math.abs(Math.round(speed * KMH_FACTOR));
            speedValueEl.innerText = kph;
            let pct = Math.abs(speed) / CAR_MAX_SPEED * 100; if (pct > 100) pct = 100;
            rpmBarEl.style.width = pct + '%';
            if (pct > 90) speedValueEl.style.color = '#ff0000'; else speedValueEl.style.color = '#00ff00';

            damageBarEl.style.width = playerDamage + '%';
            wearBarEl.style.width = playerTireWear + '%';

            if (car) {
                coordsEl.innerText = `X:${car.position.x.toFixed(1)} Y:${car.position.y.toFixed(1)} Z:${car.position.z.toFixed(1)}`;
            }

            if (onGrass) {
                grassWarningEl.style.display = 'block';
                grassWarningEl.innerText = "OFF TRACK!";
                grassWarningEl.style.color = "#ff3333";
                grassWarningEl.style.borderColor = "red";
            } else if (inPitLane) {
                grassWarningEl.style.display = 'block';
                grassWarningEl.innerText = "PIT LANE - REPAIRING";
                grassWarningEl.style.color = "#ffff00";
                grassWarningEl.style.borderColor = "yellow";
            } else {
                grassWarningEl.style.display = 'none';
            }
        }

        function updateLiveLeaderboard() {
            let playerProgr = 0;
            if (playerFinished) {
                playerProgr = TOTAL_LAPS + 1;
            } else {
                const cp = Math.max(0, lastCheckpoint);
                const lapScore = currentLap;
                const trackScore = cp / totalCheckpoints;
                playerProgr = lapScore + trackScore;
            }

            let allRacers = [];
            allRacers.push({
                name: playerDriverName,
                score: playerProgr,
                isPlayer: true
            });

            aiCars.forEach(ai => {
                let aiScore = 0;
                if (ai.finished) {
                    aiScore = TOTAL_LAPS + 1 + (1 - (ai.speed / 1000));
                    aiScore = 100;
                } else {
                    aiScore = (ai.lap) + ai.progress;
                }
                allRacers.push({
                    name: ai.name,
                    score: aiScore,
                    isPlayer: false
                });
            });

            allRacers.sort((a, b) => b.score - a.score);

            let html = "";
            const limit = 20;

            for (let i = 0; i < Math.min(limit, allRacers.length); i++) {
                const r = allRacers[i];
                const className = r.isPlayer ? "lb-row is-player" : "lb-row";
                html += `
                    <div class="${className}">
                        <div class="lb-pos">${i + 1}</div>
                        <div class="lb-name">${r.name}</div>
                    </div>
                `;
            }

            lbListEl.innerHTML = html;
        }

        function updateCamera() {
            const relativeOffset = new THREE.Vector3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE);
            const cameraOffset = relativeOffset.applyMatrix4(car.matrixWorld);
            camera.position.lerp(cameraOffset, 0.15);
            camera.lookAt(car.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function drawMinimap() {
            mapCtx.clearRect(0, 0, 200, 200);
            mapCtx.strokeStyle = '#fff'; mapCtx.lineWidth = 2; mapCtx.beginPath();
            const pad = 20; const w = 200 - pad * 2; const h = 200 - pad * 2;
            if (trackPoints2D.length > 0) {
                mapCtx.moveTo(pad + trackPoints2D[0].x * w, pad + trackPoints2D[0].y * h);
                for (let i = 1; i < trackPoints2D.length; i++) mapCtx.lineTo(pad + trackPoints2D[i].x * w, pad + trackPoints2D[i].y * h);
                mapCtx.lineTo(pad + trackPoints2D[0].x * w, pad + trackPoints2D[0].y * h);
                mapCtx.stroke();

                const bounds = trackPoints2D[0].bounds;
                aiCars.forEach(ai => {
                    const aiNX = (ai.mesh.position.x - bounds.minX) / (bounds.maxX - bounds.minX);
                    const aiNY = (ai.mesh.position.z - bounds.minZ) / (bounds.maxZ - bounds.minZ);
                    mapCtx.fillStyle = '#aaa'; mapCtx.beginPath(); mapCtx.arc(pad + aiNX * w, pad + aiNY * h, 3, 0, Math.PI * 2); mapCtx.fill();
                });
                const carNX = (car.position.x - bounds.minX) / (bounds.maxX - bounds.minX);
                const carNY = (car.position.z - bounds.minZ) / (bounds.maxZ - bounds.minZ);
                mapCtx.fillStyle = '#ff4444'; mapCtx.beginPath(); mapCtx.arc(pad + carNX * w, pad + carNY * h, 5, 0, Math.PI * 2); mapCtx.fill();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateAI();
            updateHUD();
            updateCamera();
            drawMinimap();

            if (Date.now() - lastLBUpdate > 250) {
                updateLiveLeaderboard();
                lastLBUpdate = Date.now();
            }

            renderer.render(scene, camera);
        }
    </script>
</body>

</html>