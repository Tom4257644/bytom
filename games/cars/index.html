<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Arcade Speedometer - 20 Car Grid</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            user-select: none;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        #laps {
            font-size: 30px;
        }

        #timer {
            font-size: 40px;
            font-family: 'Courier New', monospace;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 8px;
            border: 2px solid #555;
            width: fit-content;
        }

        #coords {
            font-size: 16px;
            font-family: 'Courier New', monospace;
            color: #ffff00;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid #444;
            width: fit-content;
        }

        #fade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2.5s ease-in;
            z-index: 50;
        }

        #results-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            /* Added max-height for scrolling */
            overflow-y: auto;
            /* Allow scrolling for long leaderboard */
        }

        /* Scrollbar styling for results */
        #results-screen::-webkit-scrollbar {
            width: 8px;
        }

        #results-screen::-webkit-scrollbar-track {
            background: #222;
        }

        #results-screen::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        #placing-text {
            font-size: 80px;
            font-weight: 900;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .gold {
            color: #FFD700;
        }

        .silver {
            color: #C0C0C0;
        }

        .bronze {
            color: #CD7F32;
        }

        .participant {
            color: #fff;
        }

        .dnf {
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
        }

        #leaderboard {
            width: 100%;
            border-collapse: collapse;
            background: rgba(20, 20, 20, 0.9);
            color: white;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #444;
        }

        #leaderboard th,
        #leaderboard td {
            padding: 10px;
            /* Reduced padding for longer list */
            text-align: left;
            border-bottom: 1px solid #333;
            font-size: 16px;
            /* Reduced font size */
        }

        #leaderboard th {
            background: #333;
        }

        .player-row {
            background: rgba(0, 255, 0, 0.2);
        }

        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            border-radius: 8px;
            z-index: 10;
        }

        canvas#minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        #hud-right {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            z-index: 10;
        }

        .status-bar-container {
            width: 150px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #555;
        }

        .bar-label {
            color: #ccc;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .bar-track {
            width: 100%;
            height: 6px;
            background: #333;
        }

        #damage-bar {
            height: 100%;
            width: 0%;
            background: #ff3333;
            transition: width 0.1s;
        }

        #wear-bar {
            height: 100%;
            width: 0%;
            background: #ffcc00;
            transition: width 0.1s;
        }

        #speed-container {
            width: 180px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 10px;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            text-align: right;
        }

        #speed-value {
            font-size: 40px;
            font-weight: bold;
            color: #00ff00;
        }

        #speed-unit {
            font-size: 14px;
            color: #aaa;
        }

        #rpm-bar-bg {
            width: 100%;
            height: 8px;
            background: #333;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
        }

        #rpm-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.1s;
        }

        #grass-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333;
            font-size: 40px;
            font-weight: bold;
            display: none;
            pointer-events: none;
            border: 4px solid red;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            z-index: 5;
        }

        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>

<body>

    <div id="ui-container">
        <div id="laps" class="hud-panel">LAP <span id="lap-counter">1</span> / 2</div>
        <div id="timer" class="hud-panel">00:00.00</div>
        <div id="coords" class="hud-panel">X: 0 Y: 0 Z: 0</div>
    </div>

    <div id="grass-warning">OFF TRACK!</div>

    <div id="fade-overlay"></div>
    <div id="results-screen">
        <div id="placing-text">FINISH</div>
        <table id="leaderboard">
            <thead>
                <tr>
                    <th>Pos</th>
                    <th>Driver</th>
                    <th>Time</th>
                </tr>
            </thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
        <div style="margin-top:20px; color:#aaa; font-size:14px;">Refresh page to race again</div>
    </div>

    <div id="minimap-container"><canvas id="minimap" width="200" height="200"></canvas></div>

    <div id="hud-right">
        <div class="status-bar-container">
            <div class="bar-label">VEHICLE DAMAGE</div>
            <div class="bar-track">
                <div id="damage-bar"></div>
            </div>
        </div>
        <div class="status-bar-container">
            <div class="bar-label">TIRE WEAR</div>
            <div class="bar-track">
                <div id="wear-bar"></div>
            </div>
        </div>

        <div id="speed-container">
            <span id="speed-value">0</span> <span id="speed-unit">MPH</span>
            <div id="rpm-bar-bg">
                <div id="rpm-bar-fill"></div>
            </div>
        </div>
    </div>

    <div id="controls-hint">Controls: W (Gas), S (Brake), A/D (Steer)</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONSTANTS ---
        const KMH_FACTOR = 200;

        const CAR_ACCEL = 0.1;
        const CAR_MAX_SPEED = 1;
        const CAR_TURN_SPEED = 0.085;

        const CAR_FRICTION_ROAD = 0.99;
        const CAR_FRICTION_GRASS = 0.75;

        const TRACK_RADIUS = 14;
        const PIT_LANE_RADIUS = 10;

        const CAMERA_HEIGHT = 7;
        const CAMERA_DISTANCE = 10;
        const TOTAL_LAPS = 2;

        // --- Globals ---
        let scene, camera, renderer;
        let car, aiCars = [];
        let trackCurve, pitLaneCurve;
        let keys = { w: false, a: false, s: false, d: false };

        let speed = 0;
        let angle = Math.PI;
        let velocity = new THREE.Vector3();
        let onGrass = false;
        let inPitLane = false;

        let playerDamage = 0;
        let playerTireWear = 0;
        let isDNF = false;

        let currentLap = 1;
        let lastCheckpoint = -1;
        let totalCheckpoints = 2000;
        let playerFinished = false;
        let startTime = 0;
        let totalTrackLength = 0;

        let finishedCars = 0;
        let rankings = [];

        const mapCanvas = document.getElementById('minimap');
        const mapCtx = mapCanvas.getContext('2d');
        const speedValueEl = document.getElementById('speed-value');
        const rpmBarEl = document.getElementById('rpm-bar-fill');
        const grassWarningEl = document.getElementById('grass-warning');
        const timerEl = document.getElementById('timer');
        const lapEl = document.getElementById('lap-counter');
        const coordsEl = document.getElementById('coords');
        const fadeOverlay = document.getElementById('fade-overlay');
        const resultsScreen = document.getElementById('results-screen');
        const placingText = document.getElementById('placing-text');
        const boardBody = document.getElementById('leaderboard-body');
        const damageBarEl = document.getElementById('damage-bar');
        const wearBarEl = document.getElementById('wear-bar');

        let trackPoints2D = [];
        let pitLanePointsCollision = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 200, 3000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(1000, 1500, 500);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 4000;
            const shadowSize = 3000;
            dirLight.shadow.camera.left = -shadowSize;
            dirLight.shadow.camera.right = shadowSize;
            dirLight.shadow.camera.top = shadowSize;
            dirLight.shadow.camera.bottom = -shadowSize;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            createGround();
            createTrack();
            createPitLane();
            createStartLine();

            // --- SPAWNING LOGIC ---
            const startPoint = trackCurve.getPointAt(0); // Start Line Center
            const startTangent = trackCurve.getTangentAt(0).normalize(); // Direction of track
            // Vector pointing to the right of the track
            const rightVector = new THREE.Vector3().crossVectors(startTangent, new THREE.Vector3(0, 1, 0)).normalize();

            // 1. Create Player (Front Row, Offset Left)
            const p1Pos = startPoint.clone().add(rightVector.clone().multiplyScalar(-5));
            createCar(p1Pos);

            // 2. Create 19 AI Cars (Grid Start)
            // Palette for the new cars
            const aiColors = [
                0xffeb3b, 0x0000ff, 0xffffff, 0xff00ff, 0x00ffff, 0xffaa00,
                0x8800ff, 0x00ff88, 0x88ff00, 0xaa00aa, 0x00aaaa, 0xaaaaaa,
                0x4444ff, 0xff4444, 0x44ff44, 0x884400, 0x333333, 0xeebb99, 0x990000
            ];

            const totalAICars = 19;
            const rowSpacing = 12; // Distance between rows
            const sideSpacing = 5; // Distance from center

            for (let i = 0; i < totalAICars; i++) {
                // Calculate Grid Position
                // i=0 is front row right (next to player)
                // i=1 is second row left
                // i=2 is second row right

                const row = Math.floor((i + 1) / 2); // Row index (0 is player row, but player takes left slot)
                const isRightSide = (i % 2 === 0);   // Toggle sides

                // Calculate position: Start Point - (Tangent * RowDist) + (RightVector * SideDist)
                // Note: Track goes forward, so we subtract tangent to go backwards for the grid
                const backwardDist = row * rowSpacing;
                const sideDist = isRightSide ? sideSpacing : -sideSpacing;

                const spawnPos = startPoint.clone()
                    .add(startTangent.clone().multiplyScalar(-backwardDist))
                    .add(rightVector.clone().multiplyScalar(sideDist));

                // Randomize Performance slightly
                const skillFactor = 0.94 + (Math.random() * 0.08); // Speed between 94% and 102%
                const aiMaxSpeed = CAR_MAX_SPEED * skillFactor;
                const aiBaseAccel = CAR_ACCEL * skillFactor;

                // Pick color
                const color = aiColors[i % aiColors.length];

                createAICar(`AI ${i + 1}`, spawnPos, color, aiMaxSpeed, aiBaseAccel);
            }

            startTime = Date.now();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(10000, 10000);
            const material = new THREE.MeshStandardMaterial({ color: 0x3b593b });
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        function createTrack() {
            trackCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -400),
                new THREE.Vector3(-300, 0, -800),
                new THREE.Vector3(-800, 0, -600),
                new THREE.Vector3(-1200, 0, -800),
                new THREE.Vector3(-1800, 0, -400),
                new THREE.Vector3(-1800, 0, 400),
                new THREE.Vector3(-1400, 0, 800),
                new THREE.Vector3(-1000, 0, 400),
                new THREE.Vector3(-600, 0, 1000),
                new THREE.Vector3(-200, 0, 1400),
                new THREE.Vector3(400, 0, 1400),
                new THREE.Vector3(800, 0, 1000),
                new THREE.Vector3(1200, 0, 400),
                new THREE.Vector3(1600, 0, 0),
                new THREE.Vector3(1200, 0, -600),
                new THREE.Vector3(800, 0, -800),
                new THREE.Vector3(400, 0, -400),
            ], true);
            totalTrackLength = trackCurve.getLength();

            const points = trackCurve.getPoints(1500);
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            points.forEach(p => {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.z < minZ) minZ = p.z; if (p.z > maxZ) maxZ = p.z;
            });
            trackPoints2D = points.map(p => ({
                x: (p.x - minX) / (maxX - minX),
                y: (p.z - minZ) / (maxZ - minZ),
                bounds: { minX, maxX, minZ, maxZ }
            }));

            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#3a3a3a';
            for (let i = 0; i < 200; i++) ctx.fillRect(Math.random() * 128, Math.random() * 128, 2, 2);
            const asphaltTexture = new THREE.CanvasTexture(canvas);
            asphaltTexture.wrapS = THREE.RepeatWrapping;
            asphaltTexture.wrapT = THREE.RepeatWrapping;
            asphaltTexture.repeat.set(1500, 1);

            const tubeGeo = new THREE.TubeGeometry(trackCurve, 3000, TRACK_RADIUS, 8, true);
            const mesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ map: asphaltTexture, side: THREE.DoubleSide, roughness: 0.8 }));
            mesh.scale.y = 0.05; mesh.position.y = 0.1; mesh.receiveShadow = true;
            scene.add(mesh);
        }

        function createPitLane() {
            const pitLaneCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(400, 0, -400),
                new THREE.Vector3(200, 0, -300),
                new THREE.Vector3(0, 0, -400),
            ], false);

            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#555555'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 2, 64); ctx.fillRect(62, 0, 2, 64);
            const pitTexture = new THREE.CanvasTexture(canvas);
            pitTexture.wrapS = THREE.RepeatWrapping; pitTexture.wrapT = THREE.RepeatWrapping;
            pitTexture.repeat.set(50, 1);

            const tubeGeo = new THREE.TubeGeometry(pitLaneCurve, 200, PIT_LANE_RADIUS, 8, false);
            const mesh = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({ map: pitTexture, side: THREE.DoubleSide, roughness: 0.9 }));
            mesh.scale.y = 0.05; mesh.position.y = 0.11;
            mesh.receiveShadow = true;
            scene.add(mesh);

            pitLanePointsCollision = pitLaneCurve.getSpacedPoints(200);

            const fontCanvas = document.createElement('canvas');
            fontCanvas.width = 128; fontCanvas.height = 64;
            const fCtx = fontCanvas.getContext('2d');
            fCtx.fillStyle = 'black'; fCtx.fillRect(0, 0, 128, 64);
            fCtx.fillStyle = 'yellow'; fCtx.font = 'bold 40px Arial'; fCtx.fillText("PIT", 30, 45);
            const signTex = new THREE.CanvasTexture(fontCanvas);
            const signGeo = new THREE.PlaneGeometry(10, 5);
            const signMat = new THREE.MeshBasicMaterial({ map: signTex });
            const sign = new THREE.Mesh(signGeo, signMat);
            sign.position.set(413, 10, -433);
            sign.lookAt(513, 10, -423);
            scene.add(sign);
        }

        function createStartLine() {
            const point = trackCurve.getPointAt(0);
            const tangent = trackCurve.getTangentAt(0);
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 64, 64);
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, 32, 32); ctx.fillRect(32, 32, 32, 32);
            const checkTexture = new THREE.CanvasTexture(canvas);
            checkTexture.wrapS = THREE.RepeatWrapping; checkTexture.wrapT = THREE.RepeatWrapping;
            checkTexture.repeat.set(8, 2); checkTexture.magFilter = THREE.NearestFilter;
            const geometry = new THREE.PlaneGeometry(TRACK_RADIUS * 2, 5);
            const material = new THREE.MeshBasicMaterial({ map: checkTexture, side: THREE.DoubleSide, polygonOffset: true, polygonOffsetFactor: -2 });
            const line = new THREE.Mesh(geometry, material);
            line.position.copy(point); line.position.y = 0.2;
            const rotY = Math.atan2(tangent.x, tangent.z);
            line.rotation.set(-Math.PI / 2, 0, rotY, 'YXZ');
            scene.add(line);
        }

        function getCarMesh(colorHex) {
            const group = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(2.1, 0.7, 4.4);
            const bodyMat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.2, metalness: 0.3 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.2; body.castShadow = true; group.add(body);

            const cockpitGeo = new THREE.BoxGeometry(1.9, 0.6, 2.2);
            const cockpit = new THREE.Mesh(cockpitGeo, new THREE.MeshStandardMaterial({ color: 0x111 }));
            cockpit.position.set(0, 1.5, -0.3); group.add(cockpit);

            const wingGeo = new THREE.BoxGeometry(2.2, 0.1, 0.6);
            const wing = new THREE.Mesh(wingGeo, new THREE.MeshStandardMaterial({ color: 0x111 }));
            wing.position.set(0, 1.8, -2.1); group.add(wing);

            const wheelGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.6, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111 });
            const positions = [{ x: -1.2, z: 1.6 }, { x: 1.2, z: 1.6 }, { x: -1.2, z: -1.6 }, { x: 1.2, z: -1.6 }];
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 1.0, pos.z);
                wheel.castShadow = true;
                group.add(wheel);
            });
            return group;
        }

        function createCar(startPos) {
            car = getCarMesh(0xff4444);
            car.position.copy(startPos); car.rotation.y = Math.PI;
            scene.add(car);
        }

        function createAICar(name, startPos, color, maxSpeed, accel) {
            const mesh = getCarMesh(color);
            mesh.position.copy(startPos); mesh.rotation.y = Math.PI;
            scene.add(mesh);
            aiCars.push({
                name: name,
                mesh: mesh,
                speed: 0,
                maxSpeed: maxSpeed,
                accel: accel,
                progress: 0,
                lap: 1,
                finished: false,
                laneBias: (Math.random() - 0.5) * 0.05,
                collisionPush: new THREE.Vector3(0, 0, 0)
            });
        }

        function handleKey(e, isPressed) {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = isPressed;
            if (k === 's' || k === 'arrowdown') keys.s = isPressed;
            if (k === 'a' || k === 'arrowleft') keys.a = isPressed;
            if (k === 'd' || k === 'arrowright') keys.d = isPressed;
        }

        function getFormattedTime(msTime) {
            const m = Math.floor(msTime / 60000);
            const s = Math.floor((msTime % 60000) / 1000);
            const ms = Math.floor((msTime % 1000) / 10);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function triggerDNF() {
            isDNF = true;
            fadeOverlay.style.opacity = '1';
            setTimeout(() => {
                resultsScreen.style.display = 'block';
                placingText.innerText = "DNF";
                placingText.className = "dnf";
            }, 1000);
        }

        function registerFinish(name, time, isPlayer) {
            finishedCars++;
            rankings.push({ name: name, time: time, isPlayer: isPlayer });
            const tr = document.createElement('tr');
            if (isPlayer) tr.className = 'player-row';
            tr.innerHTML = `<td>${finishedCars}</td><td>${name}</td><td>${getFormattedTime(time)}</td>`;
            boardBody.appendChild(tr);

            if (isPlayer && !isDNF) {
                playerFinished = true;
                fadeOverlay.style.opacity = '1';
                setTimeout(() => {
                    resultsScreen.style.display = 'block';
                    let placeText = "";
                    let className = "participant";
                    if (finishedCars === 1) { placeText = "1ST PLACE"; className = "gold"; }
                    else if (finishedCars === 2) { placeText = "2ND PLACE"; className = "silver"; }
                    else if (finishedCars === 3) { placeText = "3RD PLACE"; className = "bronze"; }
                    else { placeText = finishedCars + "TH PLACE"; }
                    placingText.innerText = placeText;
                    placingText.className = className;
                }, 1000);
            }
        }

        function updateAI() {
            aiCars.forEach(ai => {
                if (ai.finished) return;

                // AI Braking
                const lookAhead = 0.02;
                const tangent1 = trackCurve.getTangentAt(ai.progress).normalize();
                const tangent2 = trackCurve.getTangentAt((ai.progress + lookAhead) % 1).normalize();
                const dot = tangent1.dot(tangent2);
                let targetSpeed = ai.maxSpeed;

                if (dot < 0.98) {
                    targetSpeed = ai.maxSpeed * Math.max(0.95, dot * 0.5);
                }

                if (ai.speed > targetSpeed) {
                    ai.speed *= 0.97;
                } else {
                    if (ai.speed < ai.maxSpeed) ai.speed += ai.accel * 0.1;
                }

                ai.speed *= CAR_FRICTION_ROAD;

                const prevProgress = ai.progress;
                const speedFactor = ai.speed / totalTrackLength;
                ai.progress += speedFactor;

                if (ai.progress > 1) {
                    ai.progress -= 1;
                    ai.lap++;
                    if (ai.lap > TOTAL_LAPS) {
                        ai.finished = true;
                        ai.speed = 0;
                        registerFinish(ai.name, Date.now() - startTime, false);
                        return;
                    }
                }

                const pt = trackCurve.getPointAt(ai.progress);
                const tangent = trackCurve.getTangentAt(ai.progress).normalize();
                const normal = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();
                ai.collisionPush.multiplyScalar(0.9);
                const laneOffset = binormal.clone().multiplyScalar(ai.laneBias * 300);
                ai.mesh.position.copy(pt).add(laneOffset).add(ai.collisionPush);

                const lookPt = trackCurve.getPointAt((ai.progress + 0.001) % 1);
                const lookOffset = new THREE.Vector3().crossVectors(trackCurve.getTangentAt((ai.progress + 0.001) % 1), normal).normalize().multiplyScalar(ai.laneBias * 300);
                ai.mesh.lookAt(lookPt.add(lookOffset).add(ai.collisionPush));
            });
        }

        function resolveCollision(pos1, radius1, pos2, radius2, isAi1, aiObj1) {
            const dx = pos1.x - pos2.x; const dz = pos1.z - pos2.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            const overlap = (radius1 + radius2) - dist;
            if (overlap > 0) {
                const nx = dx / dist; const nz = dz / dist;
                const pushX = nx * overlap * 0.5; const pushZ = nz * overlap * 0.5;
                pos1.x += pushX; pos1.z += pushZ;
                pos2.x -= pushX; pos2.z -= pushZ;
                if (isAi1 && aiObj1) {
                    aiObj1.collisionPush.x += pushX; aiObj1.collisionPush.z += pushZ;
                }
                return true;
            }
            return false;
        }

        function updatePhysics() {
            // Player Physics
            if (!playerFinished && !isDNF) {
                if (keys.w) speed += CAR_ACCEL * 0.1;
                if (keys.s) speed -= CAR_ACCEL * 0.2;
            } else {
                speed *= 0.98; // Coast
            }

            speed *= (onGrass ? CAR_FRICTION_GRASS : CAR_FRICTION_ROAD);

            // DYNAMIC MAX SPEED (Pit Lane Limiter)
            let currentMaxSpeed = CAR_MAX_SPEED;
            if (inPitLane) {
                currentMaxSpeed = 80 / KMH_FACTOR;
            }

            if (speed > currentMaxSpeed) speed = currentMaxSpeed;
            if (speed < -currentMaxSpeed / 2) speed = -currentMaxSpeed / 2;

            if (Math.abs(speed) > 0.01) {
                const speedRatio = Math.abs(speed) / CAR_MAX_SPEED;
                const sensitivity = Math.max(0.15, 1.0 - (speedRatio * 0.85));
                const turn = CAR_TURN_SPEED * sensitivity;

                if (!playerFinished && !isDNF) {
                    if (keys.a) {
                        angle += turn;
                        speed *= 0.995;
                        if (playerTireWear < 100) playerTireWear += 0.05;
                    }
                    if (keys.d) {
                        angle -= turn;
                        speed *= 0.995;
                        if (playerTireWear < 100) playerTireWear += 0.05;
                    }
                }
            }

            velocity.x = Math.sin(angle) * speed;
            velocity.z = Math.cos(angle) * speed;
            car.position.x += velocity.x;
            car.position.z += velocity.z;
            car.rotation.y = angle;

            // Collisions with AI
            const carRadius = 2.0;
            aiCars.forEach(ai => {
                const hit = resolveCollision(car.position, carRadius, ai.mesh.position, carRadius, false, null);
                if (hit) {
                    const dx = ai.mesh.position.x - car.position.x;
                    const dz = ai.mesh.position.z - car.position.z;
                    ai.collisionPush.x += dx * 0.1; ai.collisionPush.z += dz * 0.1;
                    speed *= 0.98;

                    // Damage Logic
                    if (playerDamage < 100 && !isDNF && !playerFinished) {
                        playerDamage += 0.4;
                        if (playerDamage >= 100) {
                            triggerDNF();
                        }
                    }
                }
            });
            for (let i = 0; i < aiCars.length; i++) {
                for (let j = i + 1; j < aiCars.length; j++) {
                    const ai1 = aiCars[i]; const ai2 = aiCars[j];
                    const hit = resolveCollision(ai1.mesh.position, carRadius, ai2.mesh.position, carRadius, true, ai1);
                    if (hit) {
                        const dx = ai2.mesh.position.x - ai1.mesh.position.x;
                        const dz = ai2.mesh.position.z - ai1.mesh.position.z;
                        ai2.collisionPush.x += dx * 0.1; ai2.collisionPush.z += dz * 0.1;
                    }
                }
            }

            // --- TRACK & PIT LANE DETECTION LOGIC ---

            // 1. Check Main Track
            const points = trackCurve.getSpacedPoints(totalCheckpoints);
            let closestDistMain = Infinity;
            let closestIndex = -1;
            for (let i = 0; i < points.length; i++) {
                const d = car.position.distanceTo(points[i]);
                if (d < closestDistMain) { closestDistMain = d; closestIndex = i; }
            }

            // 2. Check Pit Lane
            let closestDistPit = Infinity;
            for (let i = 0; i < pitLanePointsCollision.length; i++) {
                const d = car.position.distanceTo(pitLanePointsCollision[i]);
                if (d < closestDistPit) closestDistPit = d;
            }

            // 3. Determine if "Off Track"
            const onMainTrack = closestDistMain <= TRACK_RADIUS + 1.5;
            const onPitLane = closestDistPit <= PIT_LANE_RADIUS + 1.0;

            if (onMainTrack || onPitLane) {
                onGrass = false;
            } else {
                onGrass = true;
            }

            // 4. Pit Stop Logic
            inPitLane = onPitLane && !onMainTrack;
            if (inPitLane && Math.abs(speed) < 2.0 && !playerFinished && !isDNF) {
                // Repair if moving slowly in pit
                if (playerDamage > 0) playerDamage -= 0.2;
                if (playerDamage < 0) playerDamage = 0;

                if (playerTireWear > 0) playerTireWear -= 0.2;
                if (playerTireWear < 0) playerTireWear = 0;
            }

            // Laps & Finish
            const buffer = 100;
            if (onMainTrack) {
                if (lastCheckpoint > totalCheckpoints - buffer && closestIndex < buffer) {
                    currentLap++;
                    lastCheckpoint = closestIndex;
                    if (!playerFinished && !isDNF) lapEl.innerText = currentLap;

                    if (currentLap > TOTAL_LAPS && !playerFinished && !isDNF) {
                        lapEl.innerText = "FINISH";
                        registerFinish("YOU", Date.now() - startTime, true);
                    }
                } else if (closestIndex > lastCheckpoint && closestIndex < lastCheckpoint + buffer) {
                    lastCheckpoint = closestIndex;
                }
                if (lastCheckpoint === -1 && closestIndex < buffer) lastCheckpoint = 0;
            }
        }

        function updateHUD() {
            if (!playerFinished && !isDNF) {
                const now = Date.now();
                timerEl.innerText = getFormattedTime(now - startTime);
            }

            const kph = Math.abs(Math.round(speed * KMH_FACTOR));
            speedValueEl.innerText = kph;
            let pct = Math.abs(speed) / CAR_MAX_SPEED * 100; if (pct > 100) pct = 100;
            rpmBarEl.style.width = pct + '%';
            if (pct > 90) speedValueEl.style.color = '#ff0000'; else speedValueEl.style.color = '#00ff00';

            damageBarEl.style.width = playerDamage + '%';
            wearBarEl.style.width = playerTireWear + '%';

            if (car) {
                coordsEl.innerText = `X:${car.position.x.toFixed(1)} Y:${car.position.y.toFixed(1)} Z:${car.position.z.toFixed(1)}`;
            }

            if (onGrass) {
                grassWarningEl.style.display = 'block';
                grassWarningEl.innerText = "OFF TRACK!";
                grassWarningEl.style.color = "#ff3333";
                grassWarningEl.style.borderColor = "red";
            } else if (inPitLane) {
                grassWarningEl.style.display = 'block';
                grassWarningEl.innerText = "PIT LANE - REPAIRING";
                grassWarningEl.style.color = "#ffff00";
                grassWarningEl.style.borderColor = "yellow";
            } else {
                grassWarningEl.style.display = 'none';
            }
        }

        function updateCamera() {
            const relativeOffset = new THREE.Vector3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE);
            const cameraOffset = relativeOffset.applyMatrix4(car.matrixWorld);
            camera.position.lerp(cameraOffset, 0.15);
            camera.lookAt(car.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function drawMinimap() {
            mapCtx.clearRect(0, 0, 200, 200);
            mapCtx.strokeStyle = '#fff'; mapCtx.lineWidth = 2; mapCtx.beginPath();
            const pad = 20; const w = 200 - pad * 2; const h = 200 - pad * 2;
            if (trackPoints2D.length > 0) {
                mapCtx.moveTo(pad + trackPoints2D[0].x * w, pad + trackPoints2D[0].y * h);
                for (let i = 1; i < trackPoints2D.length; i++) mapCtx.lineTo(pad + trackPoints2D[i].x * w, pad + trackPoints2D[i].y * h);
                mapCtx.lineTo(pad + trackPoints2D[0].x * w, pad + trackPoints2D[0].y * h);
                mapCtx.stroke();

                const bounds = trackPoints2D[0].bounds;
                aiCars.forEach(ai => {
                    const aiNX = (ai.mesh.position.x - bounds.minX) / (bounds.maxX - bounds.minX);
                    const aiNY = (ai.mesh.position.z - bounds.minZ) / (bounds.maxZ - bounds.minZ);
                    mapCtx.fillStyle = '#aaa'; mapCtx.beginPath(); mapCtx.arc(pad + aiNX * w, pad + aiNY * h, 3, 0, Math.PI * 2); mapCtx.fill();
                });
                const carNX = (car.position.x - bounds.minX) / (bounds.maxX - bounds.minX);
                const carNY = (car.position.z - bounds.minZ) / (bounds.maxZ - bounds.minZ);
                mapCtx.fillStyle = '#ff4444'; mapCtx.beginPath(); mapCtx.arc(pad + carNX * w, pad + carNY * h, 5, 0, Math.PI * 2); mapCtx.fill();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateAI();
            updateHUD();
            updateCamera();
            drawMinimap();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>