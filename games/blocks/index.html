<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocks</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            /* Sky color */
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10 0v20M0 10h20" stroke="white" stroke-width="2" style="mix-blend-mode: difference;"/></svg>');
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }

        #instructions {
            font-size: 24px;
            color: white;
            text-align: center;
            cursor: pointer;
            padding: 20px;
            border: 2px solid white;
            background: rgba(0, 0, 0, 0.3);
        }

        #hotbar {
            display: flex;
            justify-content: center;
            padding-bottom: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
        }

        .slot {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            margin: 0 5px;
            background-color: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .slot.active {
            border-color: #fff;
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 0.2);
        }

        .slot span {
            position: absolute;
            top: 2px;
            left: 4px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
        }

        .slot-icon {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }

        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            white-space: pre-line;
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="crosshair"></div>
    <div id="debug">BLOCKS v1.0 BETA<br>Chunks Loaded: 1</div>

    <div id="blocker">
        <div id="instructions">
            <h1>BLOCKS</h1>
            <p>Click to Play</p>
            <p style="font-size: 16px;">
                W, A, S, D to Move<br>
                SPACE to Jump<br>
                MOUSE to Look<br>
                LEFT CLICK to Mine<br>
                RIGHT CLICK to Build<br>
                1-8 to Change Block
            </p>
        </div>
    </div>

    <div id="ui-layer">
        <div></div> <!-- Spacer -->
        <div id="hotbar">
            <!-- Slots will be generated by JS -->
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION ---
        const WORLD_SIZE = 40; // Size of the active play area (blocks)
        const CHUNK_HEIGHT = 16;
        const BLOCK_SIZE = 1;

        // --- TEXTURE GENERATOR ---
        // Generates pixelated textures programmatically to avoid external assets
        function createTexture(color, type = 'noise') {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Base fill
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 64, 64);

            // Add Noise
            if (type === 'noise' || type === 'grass' || type === 'stone') {
                for (let i = 0; i < 400; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
                    const x = Math.floor(Math.random() * 64);
                    const y = Math.floor(Math.random() * 64);
                    const w = Math.floor(Math.random() * 4 + 2);
                    const h = Math.floor(Math.random() * 4 + 2);
                    ctx.fillRect(x, y, w, h);

                    ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.1})`;
                    const x2 = Math.floor(Math.random() * 64);
                    const y2 = Math.floor(Math.random() * 64);
                    ctx.fillRect(x2, y2, w, h);
                }
            }

            // Specific patterns
            if (type === 'bricks') {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                for (let y = 0; y < 64; y += 16) {
                    ctx.fillRect(0, y, 64, 2);
                    for (let x = (y % 32 === 0 ? 0 : 16); x < 64; x += 32) {
                        ctx.fillRect(x, y, 2, 16);
                    }
                }
            } else if (type === 'wood') {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for (let x = 4; x < 64; x += 8) {
                    ctx.fillRect(x, 0, 2, 64);
                }
            } else if (type === 'leaves') {
                ctx.fillStyle = 'rgba(0,50,0,0.2)';
                for (let i = 0; i < 100; i++) {
                    const x = Math.floor(Math.random() * 64);
                    const y = Math.floor(Math.random() * 64);
                    ctx.fillRect(x, y, 6, 6);
                }
            } else if (type === 'grass_side') {
                // Dirt bottom
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(0, 0, 64, 64);
                // Noise for dirt
                for (let i = 0; i < 200; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                    ctx.fillRect(Math.random() * 64, Math.random() * 64, 4, 4);
                }
                // Grass top
                ctx.fillStyle = '#4caf50';
                ctx.fillRect(0, 0, 64, 20);
                for (let i = 0; i < 20; i++) {
                    ctx.fillRect(i * 4, 15, 4, Math.random() * 10);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter; // Pixelated look
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // --- MATERIALS ---
        const materials = {
            grass: [
                new THREE.MeshLambertMaterial({ map: createTexture('#7cb342', 'grass_side') }), // Right
                new THREE.MeshLambertMaterial({ map: createTexture('#7cb342', 'grass_side') }), // Left
                new THREE.MeshLambertMaterial({ map: createTexture('#4caf50', 'grass') }),      // Top
                new THREE.MeshLambertMaterial({ map: createTexture('#5d4037', 'noise') }),      // Bottom
                new THREE.MeshLambertMaterial({ map: createTexture('#7cb342', 'grass_side') }), // Front
                new THREE.MeshLambertMaterial({ map: createTexture('#7cb342', 'grass_side') })  // Back
            ],
            dirt: new THREE.MeshLambertMaterial({ map: createTexture('#5d4037', 'noise') }),
            stone: new THREE.MeshLambertMaterial({ map: createTexture('#757575', 'stone') }),
            wood: new THREE.MeshLambertMaterial({ map: createTexture('#8d6e63', 'wood') }),
            leaves: new THREE.MeshLambertMaterial({ map: createTexture('#388e3c', 'leaves'), transparent: true, opacity: 0.9 }),
            sand: new THREE.MeshLambertMaterial({ map: createTexture('#fff59d', 'noise') }),
            glass: new THREE.MeshLambertMaterial({ map: createTexture('#e1f5fe', 'noise'), transparent: true, opacity: 0.4 }),
            bricks: new THREE.MeshLambertMaterial({ map: createTexture('#a1887f', 'bricks') }),
            highlight: new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.4 })
        };

        const blockTypes = [
            { id: 1, name: 'Grass', mat: materials.grass },
            { id: 2, name: 'Dirt', mat: materials.dirt },
            { id: 3, name: 'Stone', mat: materials.stone },
            { id: 4, name: 'Wood', mat: materials.wood },
            { id: 5, name: 'Leaves', mat: materials.leaves },
            { id: 6, name: 'Sand', mat: materials.sand },
            { id: 7, name: 'Bricks', mat: materials.bricks },
            { id: 8, name: 'Glass', mat: materials.glass },
        ];

        let selectedBlockType = 1;

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        // --- WORLD GENERATION ---
        const objects = []; // For collision and raycasting
        const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        const map = new Map(); // Store block positions "x,y,z" -> mesh

        function getMapKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        function addBlock(x, y, z, typeIndex) {
            // Remove existing if any
            const key = getMapKey(x, y, z);
            if (map.has(key)) return;

            const material = blockTypes[typeIndex].mat;
            const mesh = new THREE.Mesh(blockGeo, material);
            mesh.position.set(x, y, z);

            scene.add(mesh);
            objects.push(mesh);
            map.set(key, mesh);
        }

        function removeBlock(mesh) {
            scene.remove(mesh);
            const index = objects.indexOf(mesh);
            if (index > -1) objects.splice(index, 1);

            const key = getMapKey(mesh.position.x, mesh.position.y, mesh.position.z);
            map.delete(key);
        }

        // Simple noise function for heightmap
        function noise(x, z) {
            const val = Math.sin(x / 10) * Math.cos(z / 10) * 4 + Math.sin(x / 5) * Math.cos(z / 5) * 2;
            return Math.floor(Math.abs(val));
        }

        // Generate Terrain
        function generateWorld() {
            const offset = WORLD_SIZE / 2;
            for (let x = -offset; x < offset; x++) {
                for (let z = -offset; z < offset; z++) {
                    const h = noise(x, z);

                    // Grass on top
                    addBlock(x, h, z, 0);

                    // Dirt/Stone below
                    for (let y = h - 1; y >= -3; y--) {
                        addBlock(x, y, z, y < h - 3 ? 2 : 1); // 2=Stone, 1=Dirt
                    }

                    // Trees (Simple random)
                    if (x > -offset + 2 && x < offset - 2 && z > -offset + 2 && z < offset - 2) {
                        if (Math.random() < 0.02) {
                            createTree(x, h + 1, z);
                        }
                    }
                }
            }
        }

        function createTree(x, y, z) {
            // Trunk
            for (let i = 0; i < 4; i++) addBlock(x, y + i, z, 3); // Wood
            // Leaves
            for (let lx = x - 2; lx <= x + 2; lx++) {
                for (let ly = y + 2; ly <= y + 4; ly++) {
                    for (let lz = z - 2; lz <= z + 2; lz++) {
                        // Skip corners for rounder look
                        if (Math.abs(lx - x) === 2 && Math.abs(lz - z) === 2) continue;
                        if (lx === x && lz === z && ly < y + 4) continue; // Don't replace trunk
                        addBlock(lx, ly, lz, 4); // Leaves
                    }
                }
            }
        }

        generateWorld();

        // --- PLAYER & CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        instructions.addEventListener('click', function () {
            controls.lock();
        });

        controls.addEventListener('lock', function () {
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        });

        controls.addEventListener('unlock', function () {
            blocker.style.display = 'flex';
            instructions.style.display = 'block';
        });

        scene.add(controls.getObject());

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        // Initial spawn
        controls.getObject().position.set(0, 10, 0);

        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump === true) velocity.y += 12; canJump = false; break;

                // Inventory Selection
                case 'Digit1': selectSlot(0); break;
                case 'Digit2': selectSlot(1); break;
                case 'Digit3': selectSlot(2); break;
                case 'Digit4': selectSlot(3); break;
                case 'Digit5': selectSlot(4); break;
                case 'Digit6': selectSlot(5); break;
                case 'Digit7': selectSlot(6); break;
                case 'Digit8': selectSlot(7); break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // --- RAYCASTING (Mining/Building) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); // Center of screen is 0,0
        mouse.x = 0;
        mouse.y = 0;

        // Selection Highlight
        const highlightBox = new THREE.Mesh(
            new THREE.BoxGeometry(1.01, 1.01, 1.01),
            materials.highlight
        );
        scene.add(highlightBox);
        highlightBox.visible = false;

        document.addEventListener('mousedown', (event) => {
            if (!controls.isLocked) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const intersect = intersects[0];

                // Distance check (approx 5 blocks reach)
                if (intersect.distance > 6) return;

                if (event.button === 0) {
                    // Left Click: Destroy
                    removeBlock(intersect.object);
                } else if (event.button === 2) {
                    // Right Click: Build
                    // Get position relative to the face normal
                    const pos = new THREE.Vector3()
                        .copy(intersect.point)
                        .add(intersect.face.normal);

                    // Snap to grid
                    pos.divideScalar(BLOCK_SIZE).floor().multiplyScalar(BLOCK_SIZE).addScalar(0.5 * BLOCK_SIZE); // Round to center

                    // Don't build inside player
                    const playerPos = controls.getObject().position;
                    // Simple distance check to player head/feet
                    const distToHead = pos.distanceTo(playerPos);
                    const distToFeet = pos.distanceTo(new THREE.Vector3(playerPos.x, playerPos.y - 1.5, playerPos.z));

                    if (distToHead > 1 && distToFeet > 1) {
                        // Find selected block index in blockTypes (id-1)
                        const typeIndex = selectedBlockType - 1;
                        addBlock(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z), typeIndex);
                    }
                }
            }
        });

        // --- PHYSICS & COLLISION ---
        function checkCollision(position) {
            // Check player bounding box against world
            const playerBB = new THREE.Box3().setFromCenterAndSize(position, new THREE.Vector3(0.6, 1.8, 0.6));

            // Optimization: Only check nearby blocks
            const px = Math.round(position.x);
            const py = Math.round(position.y);
            const pz = Math.round(position.z);

            for (let x = px - 1; x <= px + 1; x++) {
                for (let y = py - 2; y <= py + 2; y++) {
                    for (let z = pz - 1; z <= pz + 1; z++) {
                        const key = getMapKey(x, y, z);
                        if (map.has(key)) {
                            const block = map.get(key);
                            const blockBB = new THREE.Box3().setFromObject(block);
                            if (playerBB.intersectsBox(blockBB)) return true;
                        }
                    }
                }
            }
            return false;
        }

        // --- UI ---
        const hotbar = document.getElementById('hotbar');

        function initHotbar() {
            blockTypes.forEach((block, index) => {
                const slot = document.createElement('div');
                slot.className = 'slot' + (index === 0 ? ' active' : '');
                slot.dataset.index = index;

                // Create icon canvas
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');

                // Draw simplified texture for icon
                if (block.mat.length) { // Array (grass)
                    // Use top texture color
                    ctx.fillStyle = '#4caf50'; // Hardcoded for simplicity or read texture data
                } else {
                    // Extract color from material (approximated)
                    // Since we use textures, we can't easily get color back, so we use a lookup or hardcode
                    const colors = ['#4caf50', '#5d4037', '#757575', '#8d6e63', '#388e3c', '#fff59d', '#a1887f', '#e1f5fe'];
                    ctx.fillStyle = colors[index];
                }
                ctx.fillRect(0, 0, 32, 32);

                slot.appendChild(canvas);

                const num = document.createElement('span');
                num.innerText = index + 1;
                slot.appendChild(num);

                hotbar.appendChild(slot);
            });
        }

        function selectSlot(index) {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(s => s.classList.remove('active'));
            if (slots[index]) {
                slots[index].classList.add('active');
                selectedBlockType = index + 1;
            }
        }

        initHotbar();

        // --- ANIMATION LOOP ---
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked === true) {

                // Raycast Highlight
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(objects);
                if (intersects.length > 0 && intersects[0].distance < 6) {
                    const i = intersects[0];
                    highlightBox.visible = true;
                    highlightBox.position.copy(i.object.position);
                } else {
                    highlightBox.visible = false;
                }

                // Physics movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 30.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // this ensures consistent movements in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta; // Speed
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                // Move X
                controls.moveRight(-velocity.x * delta);
                if (checkCollision(controls.getObject().position)) {
                    controls.moveRight(velocity.x * delta); // Undo
                    velocity.x = 0;
                }

                // Move Z
                controls.moveForward(-velocity.z * delta);
                if (checkCollision(controls.getObject().position)) {
                    controls.moveForward(velocity.z * delta); // Undo
                    velocity.z = 0;
                }

                // Move Y
                controls.getObject().position.y += (velocity.y * delta);
                if (checkCollision(controls.getObject().position)) {
                    // Collision with ground or ceiling
                    controls.getObject().position.y -= (velocity.y * delta); // Undo

                    if (velocity.y < 0) {
                        canJump = true; // Landed
                    }
                    velocity.y = 0;
                }

                // Floor limit (void)
                if (controls.getObject().position.y < -20) {
                    controls.getObject().position.set(0, 20, 0);
                    velocity.y = 0;
                }
            }

            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>