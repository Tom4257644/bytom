<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Classic Solitaire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --card-width: 80px;
            --card-height: 112px;
            --card-gap: 10px;
            --bg-color: #35654d;
        }

        @media (max-width: 600px) {
            :root {
                --card-width: 13vw;
                --card-height: 18.2vw;
                --card-gap: 2vw;
            }
        }

        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #427a5d 0%, #2a523e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            /* Prevent scrolling */
            touch-action: none;
            /* Better touch handling */
            height: 100vh;
            width: 100vw;
            user-select: none;
        }

        /* --- Layout --- */
        #game-board {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            padding: 1rem;
            max-width: 1000px;
            margin: 0 auto;
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
            height: var(--card-height);
        }

        .stock-waste-container {
            display: flex;
            gap: var(--card-gap);
        }

        .foundations-container {
            display: flex;
            gap: var(--card-gap);
        }

        .tableau-container {
            display: flex;
            justify-content: space-between;
            flex-grow: 1;
            position: relative;
        }

        .column {
            position: relative;
            width: var(--card-width);
            height: 100%;
        }

        /* --- Card Styles --- */
        .card-slot {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            position: relative;
            background: rgba(0, 0, 0, 0.1);
        }

        .card-slot.empty-foundation::before {
            content: 'A';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.2);
            font-weight: bold;
        }

        .card-slot.refresh-stock::before {
            content: '↻';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.2);
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            background-color: white;
            border-radius: 6px;
            box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.4);
            position: absolute;
            top: 0;
            left: 0;
            cursor: pointer;
            transition: transform 0.1s;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0.2rem;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 10;
        }

        /* Card Colors */
        .card.red {
            color: #d40000;
        }

        .card.black {
            color: #000;
        }

        /* Card Back */
        .card.back {
            background: #fff;
            background-image: repeating-linear-gradient(45deg,
                    #3b5998 0,
                    #3b5998 10px,
                    #fff 10px,
                    #fff 12px);
            border: 2px solid white;
            cursor: default;
        }

        .card.back::after {
            content: '';
            position: absolute;
            inset: 5px;
            border: 2px solid #3b5998;
            border-radius: 4px;
        }

        /* Selected State */
        .card.selected {
            box-shadow: 0 0 0 3px #fbbf24, 2px 4px 8px rgba(0, 0, 0, 0.5);
            transform: translateY(-5px);
            z-index: 100 !important;
        }

        /* Card Content Layout */
        .card-top,
        .card-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .card-bottom {
            transform: rotate(180deg);
        }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            opacity: 0.2;
            /* Watermark style */
        }

        /* Animations */
        @keyframes deal {
            from {
                transform: translate(-50vw, -50vh) rotate(180deg);
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .win-screen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            color: white;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            animation: fall 3s linear infinite;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(720deg);
            }
        }
    </style>
</head>

<body>

    <!-- Controls -->
    <div class="fixed top-2 right-2 z-50 flex gap-2">
        <button onclick="game.init()"
            class="bg-yellow-500 hover:bg-yellow-600 text-white text-xs px-3 py-1 rounded shadow">New Game</button>
        <button onclick="game.undo()"
            class="bg-blue-500 hover:bg-blue-600 text-white text-xs px-3 py-1 rounded shadow">Undo</button>
    </div>

    <!-- Main Board -->
    <div id="game-board">
        <!-- Top Row: Stock/Waste & Foundations -->
        <div class="top-row">
            <div class="stock-waste-container">
                <div id="stock" class="card-slot refresh-stock" onclick="game.handleStockClick()"></div>
                <div id="waste" class="card-slot"></div>
            </div>

            <div class="foundations-container">
                <div id="foundation-0" class="card-slot empty-foundation" data-type="foundation" data-idx="0"></div>
                <div id="foundation-1" class="card-slot empty-foundation" data-type="foundation" data-idx="1"></div>
                <div id="foundation-2" class="card-slot empty-foundation" data-type="foundation" data-idx="2"></div>
                <div id="foundation-3" class="card-slot empty-foundation" data-type="foundation" data-idx="3"></div>
            </div>
        </div>

        <!-- Bottom Row: Tableau -->
        <div class="tableau-container">
            <div id="tableau-0" class="column" data-type="tableau" data-idx="0"></div>
            <div id="tableau-1" class="column" data-type="tableau" data-idx="1"></div>
            <div id="tableau-2" class="column" data-type="tableau" data-idx="2"></div>
            <div id="tableau-3" class="column" data-type="tableau" data-idx="3"></div>
            <div id="tableau-4" class="column" data-type="tableau" data-idx="4"></div>
            <div id="tableau-5" class="column" data-type="tableau" data-idx="5"></div>
            <div id="tableau-6" class="column" data-type="tableau" data-idx="6"></div>
        </div>
    </div>

    <!-- Win Screen -->
    <div id="win-screen" class="win-screen">
        <h1 class="text-4xl font-bold mb-4 text-yellow-400">You Won!</h1>
        <p class="mb-6">All foundations completed.</p>
        <button onclick="game.init(); document.getElementById('win-screen').style.display='none'"
            class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-full text-xl shadow-lg transform transition hover:scale-105">Play
            Again</button>
    </div>

    <script>
        /**
         * Solitaire Logic
         * Supports: Drag/Drop, Click-to-Move, Auto-Stack (Double Click)
         */

        const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const SYMBOLS = { hearts: '♥', diamonds: '♦', clubs: '♣', spades: '♠' };
        const COLORS = { hearts: 'red', diamonds: 'red', clubs: 'black', spades: 'black' };
        const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        class Card {
            constructor(suit, value) {
                this.suit = suit;
                this.value = value; // Index 0-12
                this.faceUp = false;
                this.id = Math.random().toString(36).substr(2, 9);
            }

            get color() { return COLORS[this.suit]; }
            get displayValue() { return VALUES[this.value]; }
            get symbol() { return SYMBOLS[this.suit]; }
        }

        class Solitaire {
            constructor() {
                this.state = {
                    stock: [],
                    waste: [],
                    foundations: [[], [], [], []], // 4 piles
                    tableau: [[], [], [], [], [], [], []], // 7 piles
                    history: [] // For undo
                };
                this.dragState = {
                    card: null,
                    sourcePile: null,
                    startX: 0,
                    startY: 0
                };

                this.selectedCard = null; // For click-to-move

                this.elements = {
                    stock: document.getElementById('stock'),
                    waste: document.getElementById('waste'),
                    foundations: [0, 1, 2, 3].map(i => document.getElementById(`foundation-${i}`)),
                    tableau: [0, 1, 2, 3, 4, 5, 6].map(i => document.getElementById(`tableau-${i}`))
                };

                this.init();
            }

            // --- Game Setup ---

            init() {
                // Create Deck
                let deck = [];
                for (let s of SUITS) {
                    for (let v = 0; v < 13; v++) {
                        deck.push(new Card(s, v));
                    }
                }

                // Shuffle (Fisher-Yates)
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                // Reset State
                this.state.stock = deck;
                this.state.waste = [];
                this.state.foundations = [[], [], [], []];
                this.state.tableau = [[], [], [], [], [], [], []];
                this.state.history = [];
                this.selectedCard = null;

                // Deal
                // Column 0 gets 1 card, Col 1 gets 2...
                for (let i = 0; i < 7; i++) {
                    for (let j = i; j < 7; j++) {
                        let card = this.state.stock.pop();
                        if (i === j) card.faceUp = true; // Top card face up
                        this.state.tableau[j].push(card);
                    }
                }

                this.render();
            }

            saveState() {
                // Deep copy state for undo
                const snapshot = JSON.stringify({
                    stock: this.state.stock,
                    waste: this.state.waste,
                    foundations: this.state.foundations,
                    tableau: this.state.tableau
                });
                this.state.history.push(snapshot);
                if (this.state.history.length > 20) this.state.history.shift(); // Limit undo
            }

            undo() {
                if (this.state.history.length === 0) return;
                const prev = JSON.parse(this.state.history.pop());

                // Restore logic requires re-instantiating Card objects to keep methods
                const restoreCards = (cards) => cards.map(c => {
                    let nc = new Card(c.suit, c.value);
                    nc.faceUp = c.faceUp;
                    nc.id = c.id;
                    return nc;
                });

                this.state.stock = restoreCards(prev.stock);
                this.state.waste = restoreCards(prev.waste);
                this.state.foundations = prev.foundations.map(restoreCards);
                this.state.tableau = prev.tableau.map(restoreCards);

                this.selectedCard = null;
                this.render();
            }

            // --- Rendering ---

            createCardElement(card, locationType, locationIdx) {
                const el = document.createElement('div');
                el.className = `card ${card.faceUp ? card.color : 'back'}`;
                if (this.selectedCard && this.selectedCard.card.id === card.id) {
                    el.classList.add('selected');
                }
                el.dataset.id = card.id;

                if (card.faceUp) {
                    el.innerHTML = `
                        <div class="card-top"><span>${card.displayValue}</span><span>${card.symbol}</span></div>
                        <div class="card-center">${card.symbol}</div>
                        <div class="card-bottom"><span>${card.displayValue}</span><span>${card.symbol}</span></div>
                    `;

                    // Interaction Events
                    el.onclick = (e) => {
                        e.stopPropagation();
                        this.handleCardClick(card, locationType, locationIdx);
                    };

                    el.ondblclick = (e) => {
                        e.stopPropagation();
                        this.tryAutoMove(card, locationType, locationIdx);
                    }

                } else {
                    // Face down interaction (mostly preventing clicks unless it's stock)
                }

                return el;
            }

            render() {
                // 1. Render Stock
                this.elements.stock.innerHTML = '';
                if (this.state.stock.length > 0) {
                    const back = document.createElement('div');
                    back.className = 'card back';
                    // Visual stack effect
                    if (this.state.stock.length > 1) {
                        back.style.boxShadow = "2px 2px 0px #fff, 3px 3px 4px rgba(0,0,0,0.4)";
                    }
                    this.elements.stock.appendChild(back);
                }

                // 2. Render Waste
                this.elements.waste.innerHTML = '';
                if (this.state.waste.length > 0) {
                    // Show top 3 cards partially if needed, for now just top one
                    const topCard = this.state.waste[this.state.waste.length - 1];
                    const el = this.createCardElement(topCard, 'waste', 0);
                    this.elements.waste.appendChild(el);
                }

                // 3. Render Foundations
                this.state.foundations.forEach((pile, idx) => {
                    const container = this.elements.foundations[idx];
                    container.innerHTML = '';
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        const el = this.createCardElement(topCard, 'foundation', idx);
                        container.appendChild(el);
                    }
                    // Add click listener to empty foundation for moving Kings/Aces
                    container.onclick = () => this.handlePlaceClick('foundation', idx);
                });

                // 4. Render Tableau
                this.state.tableau.forEach((pile, idx) => {
                    const container = this.elements.tableau[idx];
                    container.innerHTML = '';

                    // Add click listener to empty column (for Kings)
                    container.onclick = (e) => {
                        if (pile.length === 0) this.handlePlaceClick('tableau', idx);
                    };

                    pile.forEach((card, cardIdx) => {
                        const el = this.createCardElement(card, 'tableau', idx);
                        // Cascade effect
                        el.style.top = `${cardIdx * (card.faceUp ? 25 : 10)}px`;
                        el.style.zIndex = cardIdx;
                        container.appendChild(el);
                    });

                    // Update container height so clicks below cards register
                    container.style.height = `${100 + (pile.length * 25)}px`;
                });

                this.checkWin();
            }

            // --- Logic ---

            handleStockClick() {
                this.saveState();
                this.selectedCard = null; // Deselect

                if (this.state.stock.length === 0) {
                    // Recycle waste to stock
                    this.state.stock = this.state.waste.reverse().map(c => { c.faceUp = false; return c; });
                    this.state.waste = [];
                } else {
                    // Draw 1
                    const card = this.state.stock.pop();
                    card.faceUp = true;
                    this.state.waste.push(card);
                }
                this.render();
            }

            handleCardClick(card, locType, locIdx) {
                // If we have a selected card, try to move it to this card
                if (this.selectedCard) {
                    if (this.selectedCard.card.id === card.id) {
                        // Clicked same card: Deselect
                        this.selectedCard = null;
                        this.render();
                    } else {
                        // Attempt move to this target card
                        this.attemptMove(this.selectedCard, { type: locType, idx: locIdx });
                    }
                } else {
                    // Select this card (only if it's moveable)
                    // Logic: Can only move top of waste, top of foundation, or any face-up in tableau
                    if (locType === 'waste' || locType === 'foundation') {
                        this.selectedCard = { card, type: locType, idx: locIdx };
                        this.render();
                    } else if (locType === 'tableau') {
                        // Can select any face up card in tableau
                        this.selectedCard = { card, type: locType, idx: locIdx };
                        this.render();
                    }
                }
            }

            handlePlaceClick(locType, locIdx) {
                // Clicking an empty spot
                if (this.selectedCard) {
                    this.attemptMove(this.selectedCard, { type: locType, idx: locIdx });
                }
            }

            tryAutoMove(card, fromType, fromIdx) {
                // Double click: Try to move to Foundation
                for (let i = 0; i < 4; i++) {
                    const pile = this.state.foundations[i];
                    if (this.isValidMove(card, 'foundation', i)) {
                        this.saveState();
                        this.executeMove({ card, type: fromType, idx: fromIdx }, { type: 'foundation', idx: i });
                        this.selectedCard = null;
                        this.render();
                        return;
                    }
                }
            }

            isValidMove(cardToMove, targetType, targetIdx) {
                // Logic to check game rules

                // 1. Moving to Foundation
                if (targetType === 'foundation') {
                    const pile = this.state.foundations[targetIdx];
                    if (pile.length === 0) {
                        return cardToMove.value === 0; // Must be Ace (0)
                    }
                    const top = pile[pile.length - 1];
                    return (top.suit === cardToMove.suit && top.value === cardToMove.value - 1);
                }

                // 2. Moving to Tableau
                if (targetType === 'tableau') {
                    const pile = this.state.tableau[targetIdx];
                    if (pile.length === 0) {
                        return cardToMove.value === 12; // Must be King (12)
                    }
                    const top = pile[pile.length - 1];
                    return (top.color !== cardToMove.color && top.value === cardToMove.value + 1);
                }

                return false;
            }

            attemptMove(source, target) {
                // Source: { card, type, idx }
                // Target: { type, idx }

                // Need to find exactly what cards are moving.
                // If tableau, might be a stack.
                let cardsToMove = [source.card];

                if (source.type === 'tableau') {
                    const pile = this.state.tableau[source.idx];
                    const cardIndex = pile.findIndex(c => c.id === source.card.id);
                    cardsToMove = pile.slice(cardIndex); // Get card and everything on top
                }

                // Check validity of the BOTTOM card of the stack moving to TARGET
                const bottomCard = cardsToMove[0];

                if (this.isValidMove(bottomCard, target.type, target.idx)) {
                    this.saveState();
                    this.executeMove(source, target);
                    this.selectedCard = null;
                    this.render();
                } else {
                    // Invalid move: shake animation?
                    this.selectedCard = null;
                    this.render();
                }
            }

            executeMove(source, target) {
                // Extract cards
                let cards = [];

                if (source.type === 'waste') {
                    cards.push(this.state.waste.pop());
                } else if (source.type === 'foundation') {
                    cards.push(this.state.foundations[source.idx].pop());
                } else if (source.type === 'tableau') {
                    const pile = this.state.tableau[source.idx];
                    const index = pile.findIndex(c => c.id === source.card.id);
                    cards = pile.splice(index);

                    // Reveal card below if exists
                    if (pile.length > 0) {
                        pile[pile.length - 1].faceUp = true;
                    }
                }

                // Add to target
                if (target.type === 'foundation') {
                    this.state.foundations[target.idx].push(cards[0]);
                } else if (target.type === 'tableau') {
                    this.state.tableau[target.idx].push(...cards);
                }
            }

            checkWin() {
                const total = this.state.foundations.reduce((acc, pile) => acc + pile.length, 0);
                if (total === 52) {
                    document.getElementById('win-screen').style.display = 'flex';
                    this.createConfetti();
                }
            }

            createConfetti() {
                for (let i = 0; i < 50; i++) {
                    const div = document.createElement('div');
                    div.className = 'confetti';
                    div.style.left = Math.random() * 100 + 'vw';
                    div.style.background = ['#f00', '#0f0', '#00f', '#ff0'][Math.floor(Math.random() * 4)];
                    div.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    document.getElementById('win-screen').appendChild(div);
                }
            }
        }

        // Start Game
        const game = new Solitaire();

    </script>
</body>

</html>